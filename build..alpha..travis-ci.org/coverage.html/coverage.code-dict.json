{"/home/travis/build/npmtest/node-npmtest-ng-annotate/test.js":"/* istanbul instrument in package npmtest_ng_annotate */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/lib.npmtest_ng_annotate.js":"/* istanbul instrument in package npmtest_ng_annotate */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ng_annotate = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ng_annotate = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ng-annotate && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ng_annotate */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ng_annotate\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ng_annotate.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ng_annotate.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ng_annotate.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ng_annotate.__dirname + '/lib.npmtest_ng_annotate.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/build/es5/ng-annotate-main.js":"// ng-annotate-main.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\nvar fmt = require(\"simple-fmt\");\nvar is = require(\"simple-is\");\nvar alter = require(\"alter\");\nvar traverse = require(\"ordered-ast-traverse\");\nvar EOL = require(\"os\").EOL;\nvar assert = require(\"assert\");\nvar ngInject = require(\"./nginject\");\nvar generateSourcemap = require(\"./generate-sourcemap\");\nvar Lut = require(\"./lut\");\nvar scopeTools = require(\"./scopetools\");\nvar stringmap = require(\"stringmap\");\nvar optionalAngularDashboardFramework = require(\"./optionals/angular-dashboard-framework\");\nvar require_acorn_t0 = Date.now();\nvar parser = require(\"acorn\").parse;\nvar require_acorn_t1 = Date.now();\n\nvar chainedRouteProvider = 1;\nvar chainedUrlRouterProvider = 2;\nvar chainedStateProvider = 3;\nvar chainedRegular = 4;\n\nfunction match(node, ctx, matchPlugins) {\n    var isMethodCall = (\n        node.type === \"CallExpression\" &&\n            node.callee.type === \"MemberExpression\" &&\n            node.callee.computed === false\n        );\n\n    // matchInjectorInvoke must happen before matchRegular\n    // to prevent false positive ($injector.invoke() outside module)\n    // matchProvide must happen before matchRegular\n    // to prevent regular from matching it as a short-form\n    var matchMethodCalls = (isMethodCall &&\n        (matchInjectorInvoke(node) || matchProvide(node, ctx) || matchRegular(node, ctx) || matchNgRoute(node) || matchMaterialShowModalOpen(node) || matchNgUi(node) || matchHttpProvider(node) || matchControllerProvider(node)));\n\n    return matchMethodCalls ||\n        (matchPlugins && matchPlugins(node)) ||\n        matchDirectiveReturnObject(node) ||\n        matchProviderGet(node);\n}\n\nfunction matchMaterialShowModalOpen(node) {\n    // $mdDialog.show({.. controller: fn, resolve: {f: function($scope) {}, ..}});\n    // $mdToast.show({.. controller: fn, resolve: {f: function($scope) {}, ..}});\n    // $mdBottomSheet.show({.. controller: fn, resolve: {f: function($scope) {}, ..}});\n    // $modal.open({.. controller: fn, resolve: {f: function($scope) {}, ..}});\n\n    // we already know that node is a (non-computed) method call\n    var callee = node.callee;\n    var obj = callee.object; // identifier or expression\n    var method = callee.property; // identifier\n    var args = node.arguments;\n\n    if (obj.type === \"Identifier\" &&\n        ((is.someof(obj.name, [\"$modal\", \"$uibModal\"]) && method.name === \"open\") || (is.someof(obj.name, [\"$mdDialog\", \"$mdToast\", \"$mdBottomSheet\"]) && method.name === \"show\")) &&\n        args.length === 1 && args[0].type === \"ObjectExpression\") {\n        var props = args[0].properties;\n        var res = [matchProp(\"controller\", props)];\n        res.push.apply(res, matchResolve(props));\n        return res.filter(Boolean);\n    }\n    return false;\n}\n\nfunction matchDirectiveReturnObject(node) {\n    // only matches inside directives\n    // return { .. controller: function($scope, $timeout), ...}\n\n    return limit(\"directive\", node.type === \"ReturnStatement\" &&\n        node.argument && node.argument.type === \"ObjectExpression\" &&\n        matchProp(\"controller\", node.argument.properties));\n}\n\nfunction limit(name, node) {\n    if (node && !node.$limitToMethodName) {\n        node.$limitToMethodName = name;\n    }\n    return node;\n}\n\nfunction matchProviderGet(node) {\n    // only matches inside providers\n    // (this|self|that).$get = function($scope, $timeout)\n    // { ... $get: function($scope, $timeout), ...}\n    var memberExpr;\n    var self;\n    return limit(\"provider\", (node.type === \"AssignmentExpression\" && (memberExpr = node.left).type === \"MemberExpression\" &&\n        memberExpr.property.name === \"$get\" &&\n        ((self = memberExpr.object).type === \"ThisExpression\" || (self.type === \"Identifier\" && is.someof(self.name, [\"self\", \"that\"]))) &&\n        node.right) ||\n        (node.type === \"ObjectExpression\" && matchProp(\"$get\", node.properties)));\n}\n\nfunction matchNgRoute(node) {\n    // $routeProvider.when(\"path\", {\n    //   ...\n    //   controller: function($scope) {},\n    //   resolve: {f: function($scope) {}, ..}\n    // })\n\n    // we already know that node is a (non-computed) method call\n    var callee = node.callee;\n    var obj = callee.object; // identifier or expression\n    if (!(obj.$chained === chainedRouteProvider || (obj.type === \"Identifier\" && obj.name === \"$routeProvider\"))) {\n        return false;\n    }\n    node.$chained = chainedRouteProvider;\n\n    var method = callee.property; // identifier\n    if (method.name !== \"when\") {\n        return false;\n    }\n\n    var args = node.arguments;\n    if (args.length !== 2) {\n        return false;\n    }\n    var configArg = last(args)\n    if (configArg.type !== \"ObjectExpression\") {\n        return false;\n    }\n\n    var props = configArg.properties;\n    var res = [\n        matchProp(\"controller\", props)\n    ];\n    // {resolve: ..}\n    res.push.apply(res, matchResolve(props));\n\n    var filteredRes = res.filter(Boolean);\n    return (filteredRes.length === 0 ? false : filteredRes);\n}\n\nfunction matchNgUi(node) {\n    // $stateProvider.state(\"myState\", {\n    //     ...\n    //     controller: function($scope)\n    //     controllerProvider: function($scope)\n    //     templateProvider: function($scope)\n    //     onEnter: function($scope)\n    //     onExit: function($scope)\n    // });\n    // $stateProvider.state(\"myState\", {... resolve: {f: function($scope) {}, ..} ..})\n    // $stateProvider.state(\"myState\", {... params: {params: {simple: function($scope) {}, inValue: { value: function($scope) {} }} ..})\n    // $stateProvider.state(\"myState\", {... views: {... somename: {... controller: fn, controllerProvider: fn, templateProvider: fn, resolve: {f: fn}}}})\n    //\n    // stateHelperProvider.setNestedState({ sameasregularstate, children: [sameasregularstate, ..]})\n    // stateHelperProvider.setNestedState({ sameasregularstate, children: [sameasregularstate, ..]}, true)\n    //\n    // $urlRouterProvider.when(.., function($scope) {})\n    //\n    // $modal.open see matchMaterialShowModalOpen\n\n    // we already know that node is a (non-computed) method call\n    var callee = node.callee;\n    var obj = callee.object; // identifier or expression\n    var method = callee.property; // identifier\n    var args = node.arguments;\n\n    // shortcut for $urlRouterProvider.when(.., function($scope) {})\n    if (obj.$chained === chainedUrlRouterProvider || (obj.type === \"Identifier\" && obj.name === \"$urlRouterProvider\")) {\n        node.$chained = chainedUrlRouterProvider;\n\n        if (method.name === \"when\" && args.length >= 1) {\n            return last(args);\n        }\n        return false;\n    }\n\n    // everything below is for $stateProvider and stateHelperProvider alone\n    if (!(obj.$chained === chainedStateProvider || (obj.type === \"Identifier\" && is.someof(obj.name, [\"$stateProvider\", \"stateHelperProvider\"])))) {\n        return false;\n    }\n    node.$chained = chainedStateProvider;\n\n    if (is.noneof(method.name, [\"state\", \"setNestedState\"])) {\n        return false;\n    }\n\n    // $stateProvider.state({ ... }) and $stateProvider.state(\"name\", { ... })\n    // stateHelperProvider.setNestedState({ .. }) and stateHelperProvider.setNestedState({ .. }, true)\n    if (!(args.length >= 1 && args.length <= 2)) {\n        return false;\n    }\n\n    var configArg = (method.name === \"state\" ? last(args) : args[0]);\n\n    var res = [];\n\n    recursiveMatch(configArg);\n\n    var filteredRes = res.filter(Boolean);\n    return (filteredRes.length === 0 ? false : filteredRes);\n\n\n    function recursiveMatch(objectExpressionNode) {\n        if (!objectExpressionNode || objectExpressionNode.type !== \"ObjectExpression\") {\n            return false;\n        }\n\n        var properties = objectExpressionNode.properties;\n\n        matchStateProps(properties, res);\n\n        var childrenArrayExpression = matchProp(\"children\", properties);\n        var children = childrenArrayExpression && childrenArrayExpression.elements;\n\n        if (!children) {\n            return;\n        }\n        children.forEach(recursiveMatch);\n    }\n\n    function matchStateProps(props, res) {\n        var simple = [\n            matchProp(\"controller\", props),\n            matchProp(\"controllerProvider\", props),\n            matchProp(\"templateProvider\", props),\n            matchProp(\"onEnter\", props),\n            matchProp(\"onExit\", props),\n        ];\n        res.push.apply(res, simple);\n\n        // {resolve: ..}\n        res.push.apply(res, matchResolve(props));\n\n        // {params: {simple: function($scope) {}, inValue: { value: function($scope) {} }}\n        var a = matchProp(\"params\", props);\n        if (a && a.type === \"ObjectExpression\") {\n            a.properties.forEach(function(prop) {\n                if (prop.value.type === \"ObjectExpression\") {\n                    res.push(matchProp(\"value\", prop.value.properties));\n                } else {\n                    res.push(prop.value);\n                }\n            });\n        }\n\n        // {view: ...}\n        var viewObject = matchProp(\"views\", props);\n        if (viewObject && viewObject.type === \"ObjectExpression\") {\n            viewObject.properties.forEach(function(prop) {\n                if (prop.value.type === \"ObjectExpression\") {\n                    res.push(matchProp(\"controller\", prop.value.properties));\n                    res.push(matchProp(\"controllerProvider\", prop.value.properties));\n                    res.push(matchProp(\"templateProvider\", prop.value.properties));\n                    res.push.apply(res, matchResolve(prop.value.properties));\n                }\n            });\n        }\n    }\n}\n\nfunction matchInjectorInvoke(node) {\n    // $injector.invoke(function($compile) { ... });\n\n    // we already know that node is a (non-computed) method call\n    var callee = node.callee;\n    var obj = callee.object; // identifier or expression\n    var method = callee.property; // identifier\n\n    return method.name === \"invoke\" &&\n        obj.type === \"Identifier\" && obj.name === \"$injector\" &&\n        node.arguments.length >= 1 && node.arguments;\n}\n\nfunction matchHttpProvider(node) {\n    // $httpProvider.interceptors.push(function($scope) {});\n    // $httpProvider.responseInterceptors.push(function($scope) {});\n\n    // we already know that node is a (non-computed) method call\n    var callee = node.callee;\n    var obj = callee.object; // identifier or expression\n    var method = callee.property; // identifier\n\n    return (method.name === \"push\" &&\n        obj.type === \"MemberExpression\" && !obj.computed &&\n        obj.object.name === \"$httpProvider\" && is.someof(obj.property.name,  [\"interceptors\", \"responseInterceptors\"]) &&\n        node.arguments.length >= 1 && node.arguments);\n}\n\nfunction matchControllerProvider(node) {\n    // $controllerProvider.register(\"foo\", function($scope) {});\n\n    // we already know that node is a (non-computed) method call\n    var callee = node.callee;\n    var obj = callee.object; // identifier or expression\n    var method = callee.property; // identifier\n    var args = node.arguments;\n\n    var target = obj.type === \"Identifier\" && obj.name === \"$controllerProvider\" &&\n        method.name === \"register\" && args.length === 2 && args[1];\n\n    if (target) {\n        target.$methodName = method.name;\n    }\n    return target;\n}\n\nfunction matchProvide(node, ctx) {\n    // $provide.decorator(\"foo\", function($scope) {});\n    // $provide.service(\"foo\", function($scope) {});\n    // $provide.factory(\"foo\", function($scope) {});\n    // $provide.provider(\"foo\", function($scope) {});\n\n    // we already know that node is a (non-computed) method call\n    var callee = node.callee;\n    var obj = callee.object; // identifier or expression\n    var method = callee.property; // identifier\n    var args = node.arguments;\n\n    var target = obj.type === \"Identifier\" && obj.name === \"$provide\" &&\n        is.someof(method.name, [\"decorator\", \"service\", \"factory\", \"provider\"]) &&\n        args.length === 2 && args[1];\n\n    if (target) {\n        target.$methodName = method.name;\n\n        if (ctx.rename) {\n            // for eventual rename purposes\n            return args;\n        }\n    }\n    return target;\n}\n\nfunction matchRegular(node, ctx) {\n    // we already know that node is a (non-computed) method call\n    var callee = node.callee;\n    var obj = callee.object; // identifier or expression\n    var method = callee.property; // identifier\n\n    // short-cut implicit config special case:\n    // angular.module(\"MyMod\", function(a) {})\n    if (obj.name === \"angular\" && method.name === \"module\") {\n        var args$0 = node.arguments;\n        if (args$0.length >= 2) {\n            node.$chained = chainedRegular;\n            return last(args$0);\n        }\n    }\n\n    // hardcoded exception: foo.decorator is generally considered a short-form\n    // declaration but $stateProvider.decorator is not. see https://github.com/olov/ng-annotate/issues/82\n    if (obj.name === \"$stateProvider\" && method.name === \"decorator\") {\n        return false;\n    }\n\n    var matchAngularModule = (obj.$chained === chainedRegular || isReDef(obj, ctx) || isLongDef(obj)) &&\n        is.someof(method.name, [\"provider\", \"value\", \"constant\", \"bootstrap\", \"config\", \"factory\", \"directive\", \"filter\", \"run\", \"controller\", \"service\", \"animation\", \"invoke\", \"store\", \"decorator\", \"component\"]);\n    if (!matchAngularModule) {\n        return false;\n    }\n    node.$chained = chainedRegular;\n\n    if (is.someof(method.name, [\"value\", \"constant\", \"bootstrap\"])) {\n        return false; // affects matchAngularModule because of chaining\n    }\n\n    var args = node.arguments;\n    var target = (is.someof(method.name, [\"config\", \"run\"]) ?\n        args.length === 1 && args[0] :\n        args.length === 2 && args[0].type === \"Literal\" && is.string(args[0].value) && args[1]);\n\n    if (method.name === \"component\") {\n        var controllerProp = (target && target.type === \"ObjectExpression\" && matchProp(\"controller\", target.properties));\n        if (!controllerProp) {\n            return false;\n        }\n        target = controllerProp;\n    }\n\n    if (target) {\n        target.$methodName = method.name;\n    }\n\n    if (ctx.rename && args.length === 2 && target) {\n        // for eventual rename purposes\n        var somethingNameLiteral = args[0];\n        return [somethingNameLiteral, target];\n    }\n    return target;\n}\n\n// matches with default regexp\n//   *.controller(\"MyCtrl\", function($scope, $timeout) {});\n//   *.*.controller(\"MyCtrl\", function($scope, $timeout) {});\n// matches with --regexp \"^require(.*)$\"\n//   require(\"app-module\").controller(\"MyCtrl\", function($scope) {});\nfunction isReDef(node, ctx) {\n    return ctx.re.test(ctx.srcForRange(node.range));\n}\n\n// Long form: angular.module(*).controller(\"MyCtrl\", function($scope, $timeout) {});\nfunction isLongDef(node) {\n    return node.callee &&\n        node.callee.object && node.callee.object.name === \"angular\" &&\n        node.callee.property && node.callee.property.name === \"module\";\n}\n\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction matchProp(name, props) {\n    for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        if ((prop.key.type === \"Identifier\" && prop.key.name === name) ||\n            (prop.key.type === \"Literal\" && prop.key.value === name)) {\n            return prop.value; // FunctionExpression or ArrayExpression\n        }\n    }\n    return null;\n}\n\nfunction matchResolve(props) {\n    var resolveObject = matchProp(\"resolve\", props);\n    if (resolveObject && resolveObject.type === \"ObjectExpression\") {\n        return resolveObject.properties.map(function(prop) {\n            return prop.value;\n        });\n    }\n    return [];\n};\n\nfunction renamedString(ctx, originalString) {\n    if (ctx.rename) {\n        return ctx.rename.get(originalString) || originalString;\n    }\n    return originalString;\n}\n\nfunction stringify(ctx, arr, quot) {\n    return \"[\" + arr.map(function(arg) {\n        return quot + renamedString(ctx, arg.name) + quot;\n    }).join(\", \") + \"]\";\n}\n\nfunction parseExpressionOfType(str, type) {\n    var node = parser(str).body[0].expression;\n    assert(node.type === type);\n    return node;\n}\n\n// stand-in for not having a jsshaper-style ref's\nfunction replaceNodeWith(node, newNode) {\n    var done = false;\n    var parent = node.$parent;\n    var keys = Object.keys(parent);\n    keys.forEach(function(key) {\n        if (parent[key] === node) {\n            parent[key] = newNode;\n            done = true;\n        }\n    });\n\n    if (done) {\n        return;\n    }\n\n    // second pass, now check arrays\n    keys.forEach(function(key) {\n        if (Array.isArray(parent[key])) {\n            var arr = parent[key];\n            for (var i = 0; i < arr.length; i++) {\n                if (arr[i] === node) {\n                    arr[i] = newNode;\n                    done = true;\n                }\n            }\n        }\n    });\n\n    assert(done);\n}\n\nfunction insertArray(ctx, functionExpression, fragments, quot) {\n    var args = stringify(ctx, functionExpression.params, quot);\n\n    fragments.push({\n        start: functionExpression.range[0],\n        end: functionExpression.range[0],\n        str: args.slice(0, -1) + \", \",\n        loc: {\n            start: functionExpression.loc.start,\n            end: functionExpression.loc.start\n        }\n    });\n    fragments.push({\n        start: functionExpression.range[1],\n        end: functionExpression.range[1],\n        str: \"]\",\n        loc: {\n            start: functionExpression.loc.end,\n            end: functionExpression.loc.end\n        }\n    });\n}\n\nfunction replaceArray(ctx, array, fragments, quot) {\n    var functionExpression = last(array.elements);\n\n    if (functionExpression.params.length === 0) {\n        return removeArray(array, fragments);\n    }\n\n    var args = stringify(ctx, functionExpression.params, quot);\n    fragments.push({\n        start: array.range[0],\n        end: functionExpression.range[0],\n        str: args.slice(0, -1) + \", \",\n        loc: {\n            start: array.loc.start,\n            end: functionExpression.loc.start\n        }\n    });\n}\n\nfunction removeArray(array, fragments) {\n    var functionExpression = last(array.elements);\n\n    fragments.push({\n        start: array.range[0],\n        end: functionExpression.range[0],\n        str: \"\",\n        loc: {\n            start: array.loc.start,\n            end: functionExpression.loc.start\n        }\n    });\n    fragments.push({\n        start: functionExpression.range[1],\n        end: array.range[1],\n        str: \"\",\n        loc: {\n            start: functionExpression.loc.end,\n            end: array.loc.end\n        }\n    });\n}\n\nfunction renameProviderDeclarationSite(ctx, literalNode, fragments) {\n    fragments.push({\n        start: literalNode.range[0] + 1,\n        end: literalNode.range[1] - 1,\n        str: renamedString(ctx, literalNode.value),\n        loc: {\n            start: {\n                line: literalNode.loc.start.line,\n                column: literalNode.loc.start.column + 1\n            }, end: {\n                line: literalNode.loc.end.line,\n                column: literalNode.loc.end.column - 1\n            }\n        }\n    });\n}\n\nfunction judgeSuspects(ctx) {\n    var mode = ctx.mode;\n    var fragments = ctx.fragments;\n    var quot = ctx.quot;\n    var blocked = ctx.blocked;\n\n    var suspects = makeUnique(ctx.suspects, 1);\n\n    for (var n = 0; n < 42; n++) {\n        // could be while(true), above is just a safety-net\n        // in practice it will loop just a couple of times\n        propagateModuleContextAndMethodName(suspects);\n        if (!setChainedAndMethodNameThroughIifesAndReferences(suspects)) {\n            break;\n        }\n    }\n\n    // create final suspects by jumping, following, uniq'ing, blocking\n    var finalSuspects = makeUnique(suspects.map(function(target) {\n        var jumped = jumpOverIife(target);\n        var jumpedAndFollowed = followReference(jumped) || jumped;\n\n        if (target.$limitToMethodName && target.$limitToMethodName !== \"*never*\" && findOuterMethodName(target) !== target.$limitToMethodName) {\n            return null;\n        }\n\n        if (blocked.indexOf(jumpedAndFollowed) >= 0) {\n            return null;\n        }\n\n        return jumpedAndFollowed;\n    }).filter(Boolean), 2);\n\n    finalSuspects.forEach(function(target) {\n        if (target.$chained !== chainedRegular) {\n            return;\n        }\n\n        if (mode === \"rebuild\" && isAnnotatedArray(target)) {\n            replaceArray(ctx, target, fragments, quot);\n        } else if (mode === \"remove\" && isAnnotatedArray(target)) {\n            removeArray(target, fragments);\n        } else if (is.someof(mode, [\"add\", \"rebuild\"]) && isFunctionExpressionWithArgs(target)) {\n            insertArray(ctx, target, fragments, quot);\n        } else if (isGenericProviderName(target)) {\n            renameProviderDeclarationSite(ctx, target, fragments);\n        } else {\n            // if it's not array or function-expression, then it's a candidate for foo.$inject = [..]\n            judgeInjectArraySuspect(target, ctx);\n        }\n    });\n\n\n    function propagateModuleContextAndMethodName(suspects) {\n        suspects.forEach(function(target) {\n            if (target.$chained !== chainedRegular && isInsideModuleContext(target)) {\n                target.$chained = chainedRegular;\n            }\n\n            if (!target.$methodName) {\n                var methodName = findOuterMethodName(target);\n                if (methodName) {\n                    target.$methodName = methodName;\n                }\n            }\n        });\n    }\n\n    function findOuterMethodName(node) {\n        for (; node && !node.$methodName; node = node.$parent) {\n        }\n        return node ? node.$methodName : null;\n    }\n\n    function setChainedAndMethodNameThroughIifesAndReferences(suspects) {\n        var modified = false;\n        suspects.forEach(function(target) {\n            var jumped = jumpOverIife(target);\n            if (jumped !== target) { // we did skip an IIFE\n                if (target.$chained === chainedRegular && jumped.$chained !== chainedRegular) {\n                    modified = true;\n                    jumped.$chained = chainedRegular;\n                }\n                if (target.$methodName && !jumped.$methodName) {\n                    modified = true;\n                    jumped.$methodName = target.$methodName;\n                }\n            }\n\n            var jumpedAndFollowed = followReference(jumped) || jumped;\n            if (jumpedAndFollowed !== jumped) { // we did follow a reference\n                if (jumped.$chained === chainedRegular && jumpedAndFollowed.$chained !== chainedRegular) {\n                    modified = true;\n                    jumpedAndFollowed.$chained = chainedRegular;\n                }\n                if (jumped.$methodName && !jumpedAndFollowed.$methodName) {\n                    modified = true;\n                    jumpedAndFollowed.$methodName = jumped.$methodName;\n                }\n            }\n        });\n        return modified;\n    }\n\n    function isInsideModuleContext(node) {\n        var $parent = node.$parent;\n        for (; $parent && $parent.$chained !== chainedRegular; $parent = $parent.$parent) {\n        }\n        return Boolean($parent);\n    }\n\n    function makeUnique(suspects, val) {\n        return suspects.filter(function(target) {\n            if (target.$seen === val) {\n                return false;\n            }\n            target.$seen = val;\n            return true;\n        });\n    }\n}\n\nfunction followReference(node) {\n    if (!scopeTools.isReference(node)) {\n        return null;\n    }\n\n    var scope = node.$scope.lookup(node.name);\n    if (!scope) {\n        return null;\n    }\n\n    var parent = scope.getNode(node.name).$parent;\n    var kind = scope.getKind(node.name);\n    if (!parent) {\n        return null;\n    }\n    var ptype = parent.type;\n\n    if (is.someof(kind, [\"const\", \"let\", \"var\"])) {\n        assert(ptype === \"VariableDeclarator\");\n        // {type: \"VariableDeclarator\", id: {type: \"Identifier\", name: \"foo\"}, init: ..}\n        return parent;\n    } else if (kind === \"fun\") {\n        assert(ptype === \"FunctionDeclaration\" || ptype === \"FunctionExpression\")\n        // FunctionDeclaration is the common case, i.e.\n        // function foo(a, b) {}\n\n        // FunctionExpression is only applicable for cases similar to\n        // var f = function asdf(a,b) { mymod.controller(\"asdf\", asdf) };\n        return parent;\n    }\n\n    // other kinds should not be handled (\"param\", \"caught\")\n\n    return null;\n}\n\n// O(srclength) so should only be used for debugging purposes, else replace with lut\nfunction posToLine(pos, src) {\n    if (pos >= src.length) {\n        pos = src.length - 1;\n    }\n\n    if (pos <= -1) {\n        return -1;\n    }\n\n    var line = 1;\n    for (var i = 0; i < pos; i++) {\n        if (src[i] === \"\\n\") {\n            ++line;\n        }\n    }\n\n    return line;\n}\n\nfunction firstNonPrologueStatement(body) {\n    for (var i = 0; i < body.length; i++) {\n        if (body[i].type !== \"ExpressionStatement\") {\n            return body[i];\n        }\n\n        var expr = body[i].expression;\n        var isStringLiteral = (expr.type === \"Literal\" && typeof expr.value === \"string\");\n        if (!isStringLiteral) {\n            return body[i];\n        }\n    }\n    return null;\n}\n\nfunction judgeInjectArraySuspect(node, ctx) {\n    if (node.type === \"VariableDeclaration\") {\n        // suspect can only be a VariableDeclaration (statement) in case of\n        // explicitly marked via /*@ngInject*/, not via references because\n        // references follow to VariableDeclarator (child)\n\n        // /*@ngInject*/ var foo = function($scope) {} and\n\n        if (node.declarations.length !== 1) {\n            // more than one declarator => exit\n            return;\n        }\n\n        // one declarator => jump over declaration into declarator\n        // rest of code will treat it as any (referenced) declarator\n        node = node.declarations[0];\n    }\n\n    // onode is a top-level node (inside function block), later verified\n    // node is inner match, descent in multiple steps\n    var onode = null;\n    var declaratorName = null;\n    if (node.type === \"VariableDeclarator\") {\n        onode = node.$parent;\n        declaratorName = node.id.name;\n        node = node.init; // var foo = ___;\n    } else {\n        onode = node;\n    }\n\n    // suspect must be inside of a block or at the top-level (i.e. inside of node.$parent.body[])\n    if (!node || !onode.$parent || is.noneof(onode.$parent.type, [\"Program\", \"BlockStatement\"])) {\n        return;\n    }\n\n    var insertPos = {\n        pos: onode.range[1],\n        loc: onode.loc.end\n    };\n    var isSemicolonTerminated = (ctx.src[insertPos.pos - 1] === \";\");\n\n    node = jumpOverIife(node);\n\n    if (ctx.isFunctionExpressionWithArgs(node)) {\n        // var x = 1, y = function(a,b) {}, z;\n\n        assert(declaratorName);\n        addRemoveInjectArray(\n            node.params,\n            isSemicolonTerminated ? insertPos : {\n                pos: node.range[1],\n                loc: node.loc.end\n            },\n            declaratorName);\n\n    } else if (ctx.isFunctionDeclarationWithArgs(node)) {\n        // /*@ngInject*/ function foo($scope) {}\n\n        addRemoveInjectArray(\n            node.params,\n            insertPos,\n            node.id.name);\n\n    } else if (node.type === \"ExpressionStatement\" && node.expression.type === \"AssignmentExpression\" &&\n        ctx.isFunctionExpressionWithArgs(node.expression.right)) {\n        // /*@ngInject*/ foo.bar[0] = function($scope) {}\n\n        var name = ctx.srcForRange(node.expression.left.range);\n        addRemoveInjectArray(\n            node.expression.right.params,\n            isSemicolonTerminated ? insertPos : {\n                pos: node.expression.right.range[1],\n                loc: node.expression.right.loc.end\n            },\n            name);\n\n    } else if (node = followReference(node)) {\n        // node was a reference and followed node now is either a\n        // FunctionDeclaration or a VariableDeclarator\n        // => recurse\n\n        judgeInjectArraySuspect(node, ctx);\n    }\n\n\n    function getIndent(pos) {\n        var src = ctx.src;\n        var lineStart = src.lastIndexOf(\"\\n\", pos - 1) + 1;\n        var i = lineStart;\n        for (; src[i] === \" \" || src[i] === \"\\t\"; i++) {\n        }\n        return src.slice(lineStart, i);\n    }\n\n    function addRemoveInjectArray(params, posAfterFunctionDeclaration, name) {\n        // if an existing something.$inject = [..] exists then is will always be recycled when rebuilding\n\n        var indent = getIndent(posAfterFunctionDeclaration.pos);\n\n        var foundSuspectInBody = false;\n        var existingExpressionStatementWithArray = null;\n        var nodeAfterExtends = null;\n        onode.$parent.body.forEach(function(bnode, idx) {\n            if (bnode === onode) {\n                foundSuspectInBody = true;\n            }\n\n            if (hasInjectArray(bnode)) {\n                if (existingExpressionStatementWithArray) {\n                    throw fmt(\"conflicting inject arrays at line {0} and {1}\",\n                        posToLine(existingExpressionStatementWithArray.range[0], ctx.src),\n                        posToLine(bnode.range[0], ctx.src));\n                }\n                existingExpressionStatementWithArray = bnode;\n            }\n\n            var e;\n            if (!nodeAfterExtends && !foundSuspectInBody && bnode.type === \"ExpressionStatement\" && (e = bnode.expression).type === \"CallExpression\" && e.callee.type === \"Identifier\" && e.callee.name === \"__extends\") {\n                var nextStatement = onode.$parent.body[idx + 1];\n                if (nextStatement) {\n                    nodeAfterExtends = nextStatement;\n                }\n            }\n        });\n        assert(foundSuspectInBody);\n        if (onode.type === \"FunctionDeclaration\") {\n            if (!nodeAfterExtends) {\n                nodeAfterExtends = firstNonPrologueStatement(onode.$parent.body);\n            }\n            if (nodeAfterExtends && !existingExpressionStatementWithArray) {\n                posAfterFunctionDeclaration = skipPrevNewline(nodeAfterExtends.range[0], nodeAfterExtends.loc.start);\n            }\n        }\n\n        function hasInjectArray(node) {\n            var lvalue;\n            var assignment;\n            return (node && node.type === \"ExpressionStatement\" && (assignment = node.expression).type === \"AssignmentExpression\" &&\n                assignment.operator === \"=\" &&\n                (lvalue = assignment.left).type === \"MemberExpression\" &&\n                ((lvalue.computed === false && ctx.srcForRange(lvalue.object.range) === name && lvalue.property.name === \"$inject\") ||\n                    (lvalue.computed === true && ctx.srcForRange(lvalue.object.range) === name && lvalue.property.type === \"Literal\" && lvalue.property.value === \"$inject\")));\n        }\n\n        function skipPrevNewline(pos, loc) {\n            var prevLF = ctx.src.lastIndexOf(\"\\n\", pos);\n            if (prevLF === -1) {\n                return { pos: pos, loc: loc };\n            }\n            if (prevLF >= 1 && ctx.src[prevLF - 1] === \"\\r\") {\n                --prevLF;\n            }\n\n            if (/\\S/g.test(ctx.src.slice(prevLF, pos - 1))) { // any non-whitespace chars between prev newline and pos?\n                return { pos: pos, loc: loc };\n            }\n\n            return {\n                pos: prevLF,\n                loc: {\n                    line: loc.line - 1,\n                    column: prevLF - ctx.src.lastIndexOf(\"\\n\", prevLF) - 1,\n                }\n            };\n        }\n\n        if (ctx.mode === \"rebuild\" && existingExpressionStatementWithArray) {\n            var strNoWhitespace = fmt(\"{2}.$inject = {3};\", null, null, name, ctx.stringify(ctx, params, ctx.quot));\n            ctx.fragments.push({\n                start: existingExpressionStatementWithArray.range[0],\n                end: existingExpressionStatementWithArray.range[1],\n                str: strNoWhitespace,\n                loc: {\n                    start: existingExpressionStatementWithArray.loc.start,\n                    end: existingExpressionStatementWithArray.loc.end\n                }\n            });\n        } else if (ctx.mode === \"remove\" && existingExpressionStatementWithArray) {\n            var start = skipPrevNewline(existingExpressionStatementWithArray.range[0], existingExpressionStatementWithArray.loc.start);\n            ctx.fragments.push({\n                start: start.pos,\n                end: existingExpressionStatementWithArray.range[1],\n                str: \"\",\n                loc: {\n                    start: start.loc,\n                    end: existingExpressionStatementWithArray.loc.end\n                }\n            });\n        } else if (is.someof(ctx.mode, [\"add\", \"rebuild\"]) && !existingExpressionStatementWithArray) {\n            var str = fmt(\"{0}{1}{2}.$inject = {3};\", EOL, indent, name, ctx.stringify(ctx, params, ctx.quot));\n            ctx.fragments.push({\n                start: posAfterFunctionDeclaration.pos,\n                end: posAfterFunctionDeclaration.pos,\n                str: str,\n                loc: {\n                    start: posAfterFunctionDeclaration.loc,\n                    end: posAfterFunctionDeclaration.loc\n                }\n            });\n        }\n    }\n}\n\nfunction jumpOverIife(node) {\n    var outerfn;\n    if (!(node.type === \"CallExpression\" && (outerfn = node.callee).type === \"FunctionExpression\")) {\n        return node;\n    }\n\n    var outerbody = outerfn.body.body;\n    for (var i = 0; i < outerbody.length; i++) {\n        var statement = outerbody[i];\n        if (statement.type === \"ReturnStatement\") {\n            return statement.argument;\n        }\n    }\n\n    return node;\n}\n\nfunction addModuleContextDependentSuspect(target, ctx) {\n    ctx.suspects.push(target);\n}\n\nfunction addModuleContextIndependentSuspect(target, ctx) {\n    target.$chained = chainedRegular;\n    ctx.suspects.push(target);\n}\n\nfunction isAnnotatedArray(node) {\n    if (node.type !== \"ArrayExpression\") {\n        return false;\n    }\n    var elements = node.elements;\n\n    // last should be a function expression\n    if (elements.length === 0 || last(elements).type !== \"FunctionExpression\") {\n        return false;\n    }\n\n    // all but last should be string literals\n    for (var i = 0; i < elements.length - 1; i++) {\n        var n = elements[i];\n        if (n.type !== \"Literal\" || !is.string(n.value)) {\n            return false;\n        }\n    }\n\n    return true;\n}\nfunction isFunctionExpressionWithArgs(node) {\n    return node.type === \"FunctionExpression\" && node.params.length >= 1;\n}\nfunction isFunctionDeclarationWithArgs(node) {\n    return node.type === \"FunctionDeclaration\" && node.params.length >= 1;\n}\nfunction isGenericProviderName(node) {\n    return node.type === \"Literal\" && is.string(node.value);\n}\n\nfunction uniqifyFragments(fragments) {\n    // must do in-place modification of ctx.fragments because shared reference\n\n    var map = Object.create(null);\n    for (var i = 0; i < fragments.length; i++) {\n        var frag = fragments[i];\n        var str = JSON.stringify({start: frag.start, end: frag.end, str: frag.str});\n        if (map[str]) {\n            fragments.splice(i, 1); // remove\n            i--;\n        } else {\n            map[str] = true;\n        }\n    }\n}\n\nvar allOptionals ={\n    \"angular-dashboard-framework\": optionalAngularDashboardFramework,\n};\n\nmodule.exports = function ngAnnotate(src, options) {\n    if (options.list) {\n        return {\n            list: Object.keys(allOptionals).sort(),\n        };\n    }\n\n    var mode = (options.add && options.remove ? \"rebuild\" :\n        options.remove ? \"remove\" :\n            options.add ? \"add\" : null);\n\n    if (!mode) {\n        return {src: src};\n    }\n\n    var quot = options.single_quotes ? \"'\" : '\"';\n    var re = (options.regexp ? new RegExp(options.regexp) : /^[a-zA-Z0-9_\\$\\.\\s]+$/);\n    var rename = new stringmap();\n    if (options.rename) {\n        options.rename.forEach(function(value) {\n            rename.set(value.from, value.to);\n        });\n    }\n    var ast;\n    var stats = {};\n\n    // detect newline and override os.EOL\n    var lf = src.lastIndexOf(\"\\n\");\n    if (lf >= 1) {\n        EOL = (src[lf - 1] === \"\\r\" ? \"\\r\\n\" : \"\\n\");\n    }\n\n    // [{type: \"Block\"|\"Line\", value: str, range: [from,to]}, ..]\n    var comments = [];\n\n    try {\n        stats.parser_require_t0 = require_acorn_t0;\n        stats.parser_require_t1 = require_acorn_t1;\n        stats.parser_parse_t0 = Date.now();\n        // acorn\n        ast = parser(src, {\n            ecmaVersion: 6,\n            allowReserved: true,\n            locations: true,\n            ranges: true,\n            onComment: comments,\n        });\n        stats.parser_parse_t1 = Date.now();\n    } catch(e) {\n        return {\n            errors: [\"error: couldn't process source due to parse error\", e.message],\n        };\n    }\n\n    // append a dummy-node to ast so that lut.findNodeFromPos(lastPos) returns something\n    ast.body.push({\n        type: \"DebuggerStatement\",\n        range: [ast.range[1], ast.range[1]],\n        loc: {\n            start: ast.loc.end,\n            end: ast.loc.end\n        }\n    });\n\n    // all source modifications are built up as operations in the\n    // fragments array, later sent to alter in one shot\n    var fragments = [];\n\n    // suspects is built up with suspect nodes by match.\n    // A suspect node will get annotations added / removed if it\n    // fulfills the arrayexpression or functionexpression look,\n    // and if it is in the correct context (inside an angular\n    // module definition)\n    var suspects = [];\n\n    // blocked is an array of blocked suspects. Any target node\n    // (final, i.e. IIFE-jumped, reference-followed and such) included\n    // in blocked will be ignored by judgeSuspects\n    var blocked = [];\n\n    // Position information for all nodes in the AST,\n    // used for sourcemap generation\n    var nodePositions = [];\n\n    var lut = new Lut(ast, src);\n\n    scopeTools.setupScopeAndReferences(ast);\n\n    var ctx = {\n        mode: mode,\n        quot: quot,\n        src: src,\n        srcForRange: function(range) {\n            return src.slice(range[0], range[1]);\n        },\n        re: re,\n        rename: rename,\n        comments: comments,\n        fragments: fragments,\n        suspects: suspects,\n        blocked: blocked,\n        lut: lut,\n        isFunctionExpressionWithArgs: isFunctionExpressionWithArgs,\n        isFunctionDeclarationWithArgs: isFunctionDeclarationWithArgs,\n        isAnnotatedArray: isAnnotatedArray,\n        addModuleContextDependentSuspect: addModuleContextDependentSuspect,\n        addModuleContextIndependentSuspect: addModuleContextIndependentSuspect,\n        stringify: stringify,\n        nodePositions: nodePositions,\n        matchResolve: matchResolve,\n        matchProp: matchProp,\n        last: last,\n    };\n\n    // setup optionals\n    var optionals = options.enable || [];\n    for (var i = 0; i < optionals.length; i++) {\n        var optional = String(optionals[i]);\n        if (!allOptionals.hasOwnProperty(optional)) {\n            return {\n                errors: [\"error: found no optional named \" + optional],\n            };\n        }\n    }\n    var optionalsPlugins = optionals.map(function(optional) {\n        return allOptionals[optional];\n    });\n\n    var plugins = [].concat(optionalsPlugins, options.plugin || []);\n\n    function matchPlugins(node, isMethodCall) {\n        for (var i = 0; i < plugins.length; i++) {\n            var res = plugins[i].match(node, isMethodCall);\n            if (res) {\n                return res;\n            }\n        }\n        return false;\n    }\n    var matchPluginsOrNull = (plugins.length === 0 ? null : matchPlugins);\n\n    ngInject.inspectComments(ctx);\n    plugins.forEach(function(plugin) {\n        plugin.init(ctx);\n    });\n\n    traverse(ast, {pre: function(node) {\n        ngInject.inspectNode(node, ctx);\n\n    }, post: function(node) {\n        ctx.nodePositions.push(node.loc.start);\n        var targets = match(node, ctx, matchPluginsOrNull);\n        if (!targets) {\n            return;\n        }\n        if (!is.array(targets)) {\n            targets = [targets];\n        }\n\n        for (var i = 0; i < targets.length; i++) {\n            addModuleContextDependentSuspect(targets[i], ctx);\n        }\n    }});\n\n    try {\n        judgeSuspects(ctx);\n    } catch(e) {\n        return {\n            errors: [\"error: \" + e],\n        };\n    }\n\n    uniqifyFragments(ctx.fragments);\n\n    var out = alter(src, fragments);\n    var result = {\n        src: out,\n        _stats: stats,\n    };\n\n    if (options.map) {\n        if (typeof(options.map) !== 'object')\n            options.map = {};\n        stats.sourcemap_t0 = Date.now();\n        generateSourcemap(result, src, nodePositions, fragments, options.map);\n        stats.sourcemap_t1 = Date.now();\n    }\n\n    return result;\n}\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/build/es5/nginject.js":"// nginject.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\n\nvar is = require(\"simple-is\");\n\nmodule.exports = {\n    inspectComments: inspectComments,\n    inspectNode: inspectNode,\n};\n\nfunction inspectNode(node, ctx) {\n    if (node.type === \"CallExpression\") {\n        inspectCallExpression(node, ctx);\n    } else if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n        inspectFunction(node, ctx);\n    }\n}\n\nfunction inspectCallExpression(node, ctx) {\n    var name = node.callee.name;\n    if (node.callee.type === \"Identifier\" && (name === \"ngInject\" || name === \"ngNoInject\") && node.arguments.length === 1) {\n        var block = (name === \"ngNoInject\");\n        addSuspect(node.arguments[0], ctx, block);\n    }\n}\n\nvar ngAnnotatePrologueDirectives = [\"ngInject\", \"ngNoInject\"];\n\nfunction inspectFunction(node, ctx) {\n    var str = matchPrologueDirectives(ngAnnotatePrologueDirectives, node);\n    if (!str) {\n        return;\n    }\n    var block = (str === \"ngNoInject\");\n\n    // now add the correct suspect\n\n    // for function declarations, it is always the function declaration node itself\n    if (node.type === \"FunctionDeclaration\") {\n        addSuspect(node, ctx, block);\n        return;\n    }\n\n    // node is a function expression below\n\n    // case 1: a function expression which is the rhs of a variable declarator, such as\n    // var f1 = function(a) {\n    //     \"ngInject\"\n    // };\n    // in this case we can mark the declarator, same as saying var /*@ngInject*/ f1 = function(a) ..\n    // or /*@ngInject*/ var f1 = function(a) ..\n    // f1.$inject = [\"a\"]; will be added (or rebuilt/removed)\n    if (node.$parent.type === \"VariableDeclarator\") {\n        addSuspect(node.$parent, ctx, block);\n        return;\n    }\n\n    // case 2: an anonymous function expression, such as\n    // g(function(a) {\n    //     \"ngInject\"\n    // });\n    //\n    // the suspect is now its parent annotated array (if any), otherwise itself\n    // there is a risk of false suspects here, in case the parent annotated array has nothing to do\n    // with annotations. the risk should be very low and hopefully easy to workaround\n    //\n    // added/rebuilt/removed => g([\"a\", function(a) {\n    //     \"ngInject\"\n    // }]);\n    var maybeArrayExpression = node.$parent;\n    if (ctx.isAnnotatedArray(maybeArrayExpression)) {\n        addSuspect(maybeArrayExpression, ctx, block);\n    } else {\n        addSuspect(node, ctx, block);\n    }\n}\n\nfunction matchPrologueDirectives(prologueDirectives, node) {\n    var body = node.body.body;\n\n    var found = null;\n    for (var i = 0; i < body.length; i++) {\n        if (body[i].type !== \"ExpressionStatement\") {\n            break;\n        }\n\n        var expr = body[i].expression;\n        var isStringLiteral = (expr.type === \"Literal\" && typeof expr.value === \"string\");\n        if (!isStringLiteral) {\n            break;\n        }\n\n        if (prologueDirectives.indexOf(expr.value) >= 0) {\n            found = expr.value;\n            break;\n        }\n    }\n\n    return found;\n}\n\nfunction inspectComments(ctx) {\n    var comments = ctx.comments;\n    for (var i = 0; i < comments.length; i++) {\n        var comment = comments[i];\n        var yesPos = comment.value.indexOf(\"@ngInject\");\n        var noPos = (yesPos === -1 ? comment.value.indexOf(\"@ngNoInject\") : -1);\n        if (yesPos === -1 && noPos === -1) {\n            continue;\n        }\n\n        var target = ctx.lut.findNodeFromPos(comment.range[1]);\n        if (!target) {\n            continue;\n        }\n\n        addSuspect(target, ctx, noPos >= 0);\n    }\n}\n\nfunction isStringArray(node) {\n    if (node.type !== \"ArrayExpression\") {\n        return false;\n    }\n    return node.elements.length >= 1 && node.elements.every(function(n) {\n        return n.type === \"Literal\" && is.string(n.value);\n    });\n}\n\nfunction findNextStatement(node) {\n    var body = node.$parent.body;\n    for (var i = 0; i < body.length; i++) {\n        if (body[i] === node) {\n            return body[i + 1] || null;\n        }\n    }\n    return null;\n}\n\nfunction addSuspect(target, ctx, block) {\n    if (target.type === \"ExpressionStatement\" && target.expression.type === \"AssignmentExpression\" && isStringArray(target.expression.right)) {\n        // /*@ngInject*/\n        // FooBar.$inject = [\"$a\", \"$b\"];\n        // function FooBar($a, $b) {}\n        var adjustedTarget = findNextStatement(target);\n        if (adjustedTarget) {\n            return addSuspect(adjustedTarget, ctx, block);\n        }\n    }\n\n    if (target.type === \"ObjectExpression\") {\n        // /*@ngInject*/ {f1: function(a), .., {f2: function(b)}}\n        addObjectExpression(target, ctx);\n    } else if (target.type === \"AssignmentExpression\" && target.right.type === \"ObjectExpression\") {\n        // /*@ngInject*/ f(x.y = {f1: function(a), .., {f2: function(b)}})\n        addObjectExpression(target.right, ctx);\n    } else if (target.type === \"ExpressionStatement\" && target.expression.type === \"AssignmentExpression\" && target.expression.right.type === \"ObjectExpression\") {\n        // /*@ngInject*/ x.y = {f1: function(a), .., {f2: function(b)}}\n        addObjectExpression(target.expression.right, ctx);\n    } else if (target.type === \"VariableDeclaration\" && target.declarations.length === 1 && target.declarations[0].init && target.declarations[0].init.type === \"ObjectExpression\") {\n        // /*@ngInject*/ var x = {f1: function(a), .., {f2: function(b)}}\n        addObjectExpression(target.declarations[0].init, ctx);\n    } else if (target.type === \"Property\") {\n        // {/*@ngInject*/ justthisone: function(a), ..}\n        target.value.$limitToMethodName = \"*never*\";\n        addOrBlock(target.value, ctx);\n    } else {\n        // /*@ngInject*/ function(a) {}\n        target.$limitToMethodName = \"*never*\";\n        addOrBlock(target, ctx);\n    }\n\n\n    function addObjectExpression(node, ctx) {\n        nestedObjectValues(node).forEach(function(n) {\n            n.$limitToMethodName = \"*never*\";\n            addOrBlock(n, ctx);\n        });\n    }\n\n    function addOrBlock(node, ctx) {\n        if (block) {\n            ctx.blocked.push(node);\n        } else {\n            ctx.addModuleContextIndependentSuspect(node, ctx)\n        }\n    }\n}\n\nfunction nestedObjectValues(node, res) {\n    res = res || [];\n\n    node.properties.forEach(function(prop) {\n        var v = prop.value;\n        if (is.someof(v.type, [\"FunctionExpression\", \"ArrayExpression\"])) {\n            res.push(v);\n        } else if (v.type === \"ObjectExpression\") {\n            nestedObjectValues(v, res);\n        }\n    });\n\n    return res;\n}\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/build/es5/generate-sourcemap.js":"\"use strict\";\n\nvar os = require(\"os\");\nvar convertSourceMap = require(\"convert-source-map\");\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\nvar SourceMapGenerator = require(\"source-map\").SourceMapGenerator;\nvar stableSort = require(\"stable\");\n\nfunction SourceMapper(src, nodePositions, fragments, inFile, sourceRoot) {\n    this.generator = new SourceMapGenerator({ sourceRoot: sourceRoot });\n    this.src = src;\n    // stableSort does not mutate input array so no need to copy it\n    this.nodePositions = stableSort(nodePositions, compareLoc);\n    this.fragments = stableSort(fragments, function(a, b) { return a.start - b.start });\n    this.inFile = inFile;\n\n    this.generator.setSourceContent(this.inFile, src);\n}\n\nSourceMapper.prototype.calculateMappings = function() {\n    var self = this;\n\n    // These offsets represent the difference in coordinates between a node in the source\n    // and the corresponding position in the output.\n    var lineOffset = 0;\n    var columnOffset = 0;\n\n    // Since the column position resets to zero after each newline, we have to keep track\n    // of the current line that columnOffset refers to in order to know whether to reset it\n    var currentLine = 0;\n\n    var frag = 0;\n    var pos = 0;\n\n    while (pos < self.nodePositions.length) {\n        while (frag < self.fragments.length &&\n            compareLoc(self.fragments[frag].loc.start, self.nodePositions[pos]) < 1) {\n\n            var fragmentLines = self.fragments[frag].str.split(\"\\n\");\n            var addedNewlines = fragmentLines.length - 1;\n\n            var replacedLines = self.fragments[frag].loc.end.line - self.fragments[frag].loc.start.line;\n            var replacedColumns = self.fragments[frag].loc.end.column - self.fragments[frag].loc.start.column;\n\n            // If there were any lines added by the fragment string, the line offset should increase;\n            // If there were any lines removed by the fragment replacement then the line offset should decrease\n            lineOffset = lineOffset + addedNewlines - replacedLines;\n\n            // The column position needs to reset after each newline.  So if the fragment added any\n            // newlines then the column offset is the difference between the column of the last line of\n            // the fragment, and the column of the end of the replaced section of the source.\n            // Otherwise we increment or decrement the column offset just like how the line offset works.\n            // Note that \"replacedColumns\" might be negative in some cases (if the beginning of the source\n            // was further right than the end due to a newline); the math still works out.\n            columnOffset = fragmentLines.length > 1 ?\n                fragmentLines[fragmentLines.length - 1].length - self.fragments[frag].loc.end.column :\n                columnOffset + self.fragments[frag].str.length - replacedColumns;\n\n            currentLine = self.fragments[frag].loc.end.line;\n\n            // Skip creating mappings for any source nodes that were replaced by this fragment (and are thus\n            // no longer a part of the output)\n            while (pos < self.nodePositions.length &&\n                compareLoc(self.fragments[frag].loc.end, self.nodePositions[pos]) > 0) {\n                ++pos;\n            }\n\n            ++frag;\n        }\n\n        if (pos < self.nodePositions.length) {\n            if (currentLine < self.nodePositions[pos].line)\n                columnOffset = 0;\n            self.addMapping(self.nodePositions[pos], {\n                line: self.nodePositions[pos].line + lineOffset,\n                column: self.nodePositions[pos].column + columnOffset\n            });\n            ++pos;\n        }\n    }\n}\n\nSourceMapper.prototype.addMapping = function(input, output) {\n    this.generator.addMapping({\n        source: this.inFile,\n        original: input,\n        generated: output\n    });\n}\n\nSourceMapper.prototype.applySourceMap = function (consumer) {\n    this.generator.applySourceMap(consumer);\n}\n\nSourceMapper.prototype.generate = function () {\n    return this.generator.toString();\n}\n\nfunction compareLoc(a, b) {\n    return (a.line - b.line) || (a.column - b.column);\n}\n\nmodule.exports = function generateSourcemap(result, src, nodePositions, fragments, mapOpts) {\n    var existingMap = convertSourceMap.fromSource(src);\n    var existingMapObject = existingMap && existingMap.toObject();\n    var inFile = (existingMapObject && existingMapObject.file) || mapOpts.inFile || \"source.js\";\n    var sourceRoot = (existingMapObject && existingMapObject.sourceRoot) || mapOpts.sourceRoot;\n    src = convertSourceMap.removeMapFileComments(src);\n\n    var mapper = new SourceMapper(src, nodePositions, fragments, inFile, sourceRoot);\n    mapper.calculateMappings();\n\n    if (mapOpts.inline) {\n        if (existingMapObject)\n            mapper.applySourceMap(new SourceMapConsumer(existingMapObject));\n\n        result.src = convertSourceMap.removeMapFileComments(result.src) +\n            os.EOL +\n            convertSourceMap.fromJSON(mapper.generate()).toComment();\n    } else {\n        result.map = mapper.generate();\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/build/es5/lut.js":"// lut.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\n\nvar assert = require(\"assert\");\nvar traverse = require(\"ordered-ast-traverse\");\nvar is = require(\"simple-is\");\n\nmodule.exports = Lut;\n\nfunction Lut(ast, src) {\n    assert(this instanceof Lut);\n\n    var sparseBegins = new Array(src.length);\n    var begins = [];\n    var sparseEnds = new Array(src.length);\n    var ends = [];\n    var p = 0;\n    var t0 = Date.now();\n    traverse(ast, {pre: function(node) {\n        //        assert (node.range[0] >= p);\n        if (node.type === \"Program\") {\n            return;\n        }\n        p = node.range[0];\n        if (!sparseBegins[p]) {\n            sparseBegins[p] = node;\n        }\n        p = node.range[1];\n        if (!sparseEnds[p]) {\n            sparseEnds[p] = node;\n        }\n    }});\n    for (var i in sparseBegins) {\n        begins.push(sparseBegins[i]);\n    }\n    for (var i$0 in sparseEnds) {\n        ends.push(sparseEnds[i$0]);\n    }\n    var t1 = Date.now();\n    //    console.error(t1-t0)\n\n    // begins and ends are compact arrays with nodes,\n    // sorted on node.range[0/1] (unique)\n    this.begins = begins;\n    this.ends = ends;\n}\n\nLut.prototype.findNodeFromPos = findNodeFromPos;\nLut.prototype.findNodeBeforePos = findNodeBeforePos;\n\n// binary search lut to find node beginning at pos\n// or as close after pos as possible. null if none\nfunction findNodeFromPos(pos) {\n    var lut = this.begins;\n    assert(is.finitenumber(pos) && pos >= 0);\n\n    var left = 0;\n    var right = lut.length - 1;\n    while (left < right) {\n        var mid = Math.floor((left + right) / 2);\n        assert(mid >= 0 && mid < lut.length);\n        if (pos > lut[mid].range[0]) {\n            left = mid + 1;\n        }\n        else {\n            right = mid;\n        }\n    }\n    if (left > right) {\n        assert(last(lut).range[0] < pos);\n        return null;\n    }\n\n    var found = left;\n    var foundPos = lut[found].range[0];\n    assert(foundPos >= pos);\n    if (found >= 1) {\n        var prevPos = lut[found - 1].range[0];\n        assert(prevPos < pos);\n    }\n\n    return lut[found];\n}\n\n// binary search lut to find node ending (as in range[1]\n// at or before pos. null if none\nfunction findNodeBeforePos(pos) {\n    var lut = this.ends;\n    assert(is.finitenumber(pos) && pos >= 0);\n\n    var left = 0;\n    var right = lut.length - 1;\n    while (left < right) {\n        var mid = Math.ceil((left + right) / 2);\n        assert(mid >= 0 && mid < lut.length);\n        if (pos < lut[mid].range[1]) {\n            right = mid - 1;\n        }\n        else {\n            left = mid;\n        }\n    }\n    if (left > right) {\n        assert(lut[0].range[1] > pos);\n        return null;\n    }\n\n    var found = left;\n    var foundPos = lut[found].range[1];\n    if(foundPos > pos) {\n        return null;\n    }\n    if (found <= lut.length - 2) {\n        var nextPos = lut[found + 1].range[1];\n        assert(nextPos > pos);\n    }\n\n    return lut[found];\n}\n\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/build/es5/scopetools.js":"// scopetools.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\n\nvar assert = require(\"assert\");\nvar traverse = require(\"ordered-ast-traverse\");\nvar Scope = require(\"./scope\");\nvar is = require(\"simple-is\");\n\nmodule.exports = {\n    setupScopeAndReferences: setupScopeAndReferences,\n    isReference: isReference,\n};\n\nfunction setupScopeAndReferences(root) {\n    traverse(root, {pre: createScopes});\n    createTopScope(root.$scope);\n}\n\nfunction createScopes(node, parent) {\n    node.$parent = parent;\n    node.$scope = parent ? parent.$scope : null; // may be overridden\n\n    if (isNonFunctionBlock(node, parent)) {\n        // A block node is a scope unless parent is a function\n        node.$scope = new Scope({\n            kind: \"block\",\n            node: node,\n            parent: parent.$scope,\n        });\n\n    } else if (node.type === \"VariableDeclaration\") {\n        // Variable declarations names goes in current scope\n        node.declarations.forEach(function(declarator) {\n            var name = declarator.id.name;\n            node.$scope.add(name, node.kind, declarator.id, declarator.range[1]);\n        });\n\n    } else if (isFunction(node)) {\n        // Function is a scope, with params in it\n        // There's no block-scope under it\n\n        node.$scope = new Scope({\n            kind: \"hoist\",\n            node: node,\n            parent: parent.$scope,\n        });\n\n        // function has a name\n        if (node.id) {\n            if (node.type === \"FunctionDeclaration\") {\n                // Function name goes in parent scope for declared functions\n                parent.$scope.add(node.id.name, \"fun\", node.id, null);\n            } else if (node.type === \"FunctionExpression\") {\n                // Function name goes in function's scope for named function expressions\n                node.$scope.add(node.id.name, \"fun\", node.id, null);\n            } else {\n                assert(false);\n            }\n        }\n\n        node.params.forEach(function(param) {\n            node.$scope.add(param.name, \"param\", param, null);\n        });\n\n    } else if (isForWithConstLet(node) || isForInOfWithConstLet(node)) {\n        // For(In/Of) loop with const|let declaration is a scope, with declaration in it\n        // There may be a block-scope under it\n        node.$scope = new Scope({\n            kind: \"block\",\n            node: node,\n            parent: parent.$scope,\n        });\n\n    } else if (node.type === \"CatchClause\") {\n        var identifier = node.param;\n\n        node.$scope = new Scope({\n            kind: \"catch-block\",\n            node: node,\n            parent: parent.$scope,\n        });\n        node.$scope.add(identifier.name, \"caught\", identifier, null);\n\n        // All hoist-scope keeps track of which variables that are propagated through,\n        // i.e. an reference inside the scope points to a declaration outside the scope.\n        // This is used to mark \"taint\" the name since adding a new variable in the scope,\n        // with a propagated name, would change the meaning of the existing references.\n        //\n        // catch(e) is special because even though e is a variable in its own scope,\n        // we want to make sure that catch(e){let e} is never transformed to\n        // catch(e){var e} (but rather var e$0). For that reason we taint the use of e\n        // in the closest hoist-scope, i.e. where var e$0 belongs.\n        node.$scope.closestHoistScope().markPropagates(identifier.name);\n\n    } else if (node.type === \"Program\") {\n        // Top-level program is a scope\n        // There's no block-scope under it\n        node.$scope = new Scope({\n            kind: \"hoist\",\n            node: node,\n            parent: null,\n        });\n    }\n}\n\nfunction createTopScope(programScope) {\n    function inject(obj) {\n        for (var name in obj) {\n            var writeable = obj[name];\n            var kind = (writeable ? \"var\" : \"const\");\n            if (topScope.hasOwn(name)) {\n                topScope.remove(name);\n            }\n            topScope.add(name, kind, {loc: {start: {line: -1}}}, -1);\n        }\n    }\n\n    var topScope = new Scope({\n        kind: \"hoist\",\n        node: {},\n        parent: null,\n    });\n\n    var complementary = {\n        undefined: false,\n        Infinity: false,\n        console: false,\n    };\n\n    inject(complementary);\n//    inject(jshint_vars.reservedVars);\n//    inject(jshint_vars.ecmaIdentifiers);\n\n    // link it in\n    programScope.parent = topScope;\n    topScope.children.push(programScope);\n\n    return topScope;\n}\n\nfunction isConstLet(kind) {\n    return kind === \"const\" || kind === \"let\";\n}\n\nfunction isNonFunctionBlock(node, parent) {\n    return node.type === \"BlockStatement\" && parent.type !== \"FunctionDeclaration\" && parent.type !== \"FunctionExpression\";\n}\n\nfunction isForWithConstLet(node) {\n    return node.type === \"ForStatement\" && node.init && node.init.type === \"VariableDeclaration\" && isConstLet(node.init.kind);\n}\n\nfunction isForInOfWithConstLet(node) {\n    return isForInOf(node) && node.left.type === \"VariableDeclaration\" && isConstLet(node.left.kind);\n}\n\nfunction isForInOf(node) {\n    return node.type === \"ForInStatement\" || node.type === \"ForOfStatement\";\n}\n\nfunction isFunction(node) {\n    return node.type === \"FunctionDeclaration\" || node.type === \"FunctionExpression\";\n}\n\nfunction isReference(node) {\n    var parent = node.$parent;\n    return node.$refToScope ||\n        node.type === \"Identifier\" &&\n            !(parent.type === \"VariableDeclarator\" && parent.id === node) && // var|let|const $\n            !(parent.type === \"MemberExpression\" && parent.computed === false && parent.property === node) && // obj.$\n            !(parent.type === \"Property\" && parent.key === node) && // {$: ...}\n            !(parent.type === \"LabeledStatement\" && parent.label === node) && // $: ...\n            !(parent.type === \"CatchClause\" && parent.param === node) && // catch($)\n            !(isFunction(parent) && parent.id === node) && // function $(..\n            !(isFunction(parent) && is.someof(node, parent.params)) && // function f($)..\n            true;\n}\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/build/es5/scope.js":"// scope.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\n\nvar assert = require(\"assert\");\nvar stringmap = require(\"stringmap\");\nvar stringset = require(\"stringset\");\nvar is = require(\"simple-is\");\nvar fmt = require(\"simple-fmt\");\n\nfunction Scope(args) {\n    assert(is.someof(args.kind, [\"hoist\", \"block\", \"catch-block\"]));\n    assert(is.object(args.node));\n    assert(args.parent === null || is.object(args.parent));\n\n    // kind === \"hoist\": function scopes, program scope, injected globals\n    // kind === \"block\": ES6 block scopes\n    // kind === \"catch-block\": catch block scopes\n    this.kind = args.kind;\n\n    // the AST node the block corresponds to\n    this.node = args.node;\n\n    // parent scope\n    this.parent = args.parent;\n\n    // children scopes for easier traversal (populated internally)\n    this.children = [];\n\n    // scope declarations. decls[variable_name] = {\n    //     kind: \"fun\" for functions,\n    //           \"param\" for function parameters,\n    //           \"caught\" for catch parameter\n    //           \"var\",\n    //           \"const\",\n    //           \"let\"\n    //     node: the AST node the declaration corresponds to\n    //     from: source code index from which it is visible at earliest\n    //           (only stored for \"const\", \"let\" [and \"var\"] nodes)\n    // }\n    this.decls = stringmap();\n\n    // names of all variables declared outside this hoist scope but\n    // referenced in this scope (immediately or in child).\n    // only stored on hoist scopes for efficiency\n    // (because we currently generate lots of empty block scopes)\n    this.propagates = (this.kind === \"hoist\" ? stringset() : null);\n\n    // scopes register themselves with their parents for easier traversal\n    if (this.parent) {\n        this.parent.children.push(this);\n    }\n}\n\nScope.prototype.print = function(indent) {\n    indent = indent || 0;\n    var scope = this;\n    var names = this.decls.keys().map(function(name) {\n        return fmt(\"{0} [{1}]\", name, scope.decls.get(name).kind);\n    }).join(\", \");\n    var propagates = this.propagates ? this.propagates.items().join(\", \") : \"\";\n    console.log(fmt(\"{0}{1}: {2}. propagates: {3}\", fmt.repeat(\" \", indent), this.node.type, names, propagates));\n    this.children.forEach(function(c) {\n        c.print(indent + 2);\n    });\n};\n\nScope.prototype.add = function(name, kind, node, referableFromPos) {\n    assert(is.someof(kind, [\"fun\", \"param\", \"var\", \"caught\", \"const\", \"let\"]));\n\n    function isConstLet(kind) {\n        return is.someof(kind, [\"const\", \"let\"]);\n    }\n\n    var scope = this;\n\n    // search nearest hoist-scope for fun, param and var's\n    // const, let and caught variables go directly in the scope (which may be hoist, block or catch-block)\n    if (is.someof(kind, [\"fun\", \"param\", \"var\"])) {\n        while (scope.kind !== \"hoist\") {\n//            if (scope.decls.has(name) && isConstLet(scope.decls.get(name).kind)) { // could be caught\n//                return error(getline(node), \"{0} is already declared\", name);\n//            }\n            scope = scope.parent;\n        }\n    }\n    // name exists in scope and either new or existing kind is const|let => error\n//    if (scope.decls.has(name) && (isConstLet(scope.decls.get(name).kind) || isConstLet(kind))) {\n//        return error(getline(node), \"{0} is already declared\", name);\n//    }\n\n    var declaration = {\n        kind: kind,\n        node: node,\n    };\n    if (referableFromPos) {\n        assert(is.someof(kind, [\"var\", \"const\", \"let\"]));\n        declaration.from = referableFromPos;\n    }\n    scope.decls.set(name, declaration);\n};\n\nScope.prototype.getKind = function(name) {\n    assert(is.string(name));\n    var decl = this.decls.get(name);\n    return decl ? decl.kind : null;\n};\n\nScope.prototype.getNode = function(name) {\n    assert(is.string(name));\n    var decl = this.decls.get(name);\n    return decl ? decl.node : null;\n};\n\nScope.prototype.getFromPos = function(name) {\n    assert(is.string(name));\n    var decl = this.decls.get(name);\n    return decl ? decl.from : null;\n};\n\nScope.prototype.hasOwn = function(name) {\n    return this.decls.has(name);\n};\n\nScope.prototype.remove = function(name) {\n    return this.decls.remove(name);\n};\n\nScope.prototype.doesPropagate = function(name) {\n    return this.propagates.has(name);\n};\n\nScope.prototype.markPropagates = function(name) {\n    this.propagates.add(name);\n};\n\nScope.prototype.closestHoistScope = function() {\n    var scope = this;\n    while (scope.kind !== \"hoist\") {\n        scope = scope.parent;\n    }\n    return scope;\n};\n\nScope.prototype.lookup = function(name) {\n    for (var scope = this; scope; scope = scope.parent) {\n        if (scope.decls.has(name)) {\n            return scope;\n        } else if (scope.kind === \"hoist\") {\n            scope.propagates.add(name);\n        }\n    }\n    return null;\n};\n\nmodule.exports = Scope;\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/build/es5/optionals/angular-dashboard-framework.js":"\"use strict\";\n\nvar ctx = null;\nmodule.exports = {\n    init: function(_ctx) {\n        ctx = _ctx;\n    },\n\n    match: function(node) {\n        // dashboardProvider.widget(\"name\", {\n        //   ...\n        //   controller: function($scope) {},\n        //   resolve: {f: function($scope) {}, ..}\n        // })\n\n        var callee = node.callee;\n        if (!callee) {\n            return false;\n        }\n\n        var obj = callee.object;\n        if (!obj) {\n            return false;\n        }\n\n        // identifier or expression\n        if (!(obj.$chained === 1 || (obj.type === \"Identifier\" && obj.name === \"dashboardProvider\"))) {\n            return false;\n        }\n\n        node.$chained = 1;\n\n        var method = callee.property; // identifier\n        if (method.name !== \"widget\") {\n            return false;\n        }\n\n        var args = node.arguments;\n        if (args.length !== 2) {\n            return false;\n        }\n\n        var configArg = ctx.last(args);\n        if (configArg.type !== \"ObjectExpression\") {\n            return false;\n        }\n\n        var props = configArg.properties;\n        var res = [\n            ctx.matchProp(\"controller\", props)\n        ];\n        // {resolve: ..}\n        res.push.apply(res, ctx.matchResolve(props));\n\n        // edit: {controller: function(), resolve: {}, apply: function()}\n        var edit = ctx.matchProp('edit', props);\n        if (edit && edit.type === \"ObjectExpression\") {\n            var editProps = edit.properties;\n            res.push(ctx.matchProp('controller', editProps));\n            res.push(ctx.matchProp('apply', editProps));\n            res.push.apply(res, ctx.matchResolve(editProps));\n        }\n\n        var filteredRes = res.filter(Boolean);\n        return (filteredRes.length === 0 ? false : filteredRes);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/generate-sourcemap.js":"\"use strict\";\n\nconst os = require(\"os\");\nconst convertSourceMap = require(\"convert-source-map\");\nconst SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\nconst SourceMapGenerator = require(\"source-map\").SourceMapGenerator;\nconst stableSort = require(\"stable\");\n\nfunction SourceMapper(src, nodePositions, fragments, inFile, sourceRoot) {\n    this.generator = new SourceMapGenerator({ sourceRoot: sourceRoot });\n    this.src = src;\n    // stableSort does not mutate input array so no need to copy it\n    this.nodePositions = stableSort(nodePositions, compareLoc);\n    this.fragments = stableSort(fragments, function(a, b) { return a.start - b.start });\n    this.inFile = inFile;\n\n    this.generator.setSourceContent(this.inFile, src);\n}\n\nSourceMapper.prototype.calculateMappings = function() {\n    const self = this;\n\n    // These offsets represent the difference in coordinates between a node in the source\n    // and the corresponding position in the output.\n    let lineOffset = 0;\n    let columnOffset = 0;\n\n    // Since the column position resets to zero after each newline, we have to keep track\n    // of the current line that columnOffset refers to in order to know whether to reset it\n    let currentLine = 0;\n\n    let frag = 0;\n    let pos = 0;\n\n    while (pos < self.nodePositions.length) {\n        while (frag < self.fragments.length &&\n            compareLoc(self.fragments[frag].loc.start, self.nodePositions[pos]) < 1) {\n\n            const fragmentLines = self.fragments[frag].str.split(\"\\n\");\n            const addedNewlines = fragmentLines.length - 1;\n\n            const replacedLines = self.fragments[frag].loc.end.line - self.fragments[frag].loc.start.line;\n            const replacedColumns = self.fragments[frag].loc.end.column - self.fragments[frag].loc.start.column;\n\n            // If there were any lines added by the fragment string, the line offset should increase;\n            // If there were any lines removed by the fragment replacement then the line offset should decrease\n            lineOffset = lineOffset + addedNewlines - replacedLines;\n\n            // The column position needs to reset after each newline.  So if the fragment added any\n            // newlines then the column offset is the difference between the column of the last line of\n            // the fragment, and the column of the end of the replaced section of the source.\n            // Otherwise we increment or decrement the column offset just like how the line offset works.\n            // Note that \"replacedColumns\" might be negative in some cases (if the beginning of the source\n            // was further right than the end due to a newline); the math still works out.\n            columnOffset = fragmentLines.length > 1 ?\n                fragmentLines[fragmentLines.length - 1].length - self.fragments[frag].loc.end.column :\n                columnOffset + self.fragments[frag].str.length - replacedColumns;\n\n            currentLine = self.fragments[frag].loc.end.line;\n\n            // Skip creating mappings for any source nodes that were replaced by this fragment (and are thus\n            // no longer a part of the output)\n            while (pos < self.nodePositions.length &&\n                compareLoc(self.fragments[frag].loc.end, self.nodePositions[pos]) > 0) {\n                ++pos;\n            }\n\n            ++frag;\n        }\n\n        if (pos < self.nodePositions.length) {\n            if (currentLine < self.nodePositions[pos].line)\n                columnOffset = 0;\n            self.addMapping(self.nodePositions[pos], {\n                line: self.nodePositions[pos].line + lineOffset,\n                column: self.nodePositions[pos].column + columnOffset\n            });\n            ++pos;\n        }\n    }\n}\n\nSourceMapper.prototype.addMapping = function(input, output) {\n    this.generator.addMapping({\n        source: this.inFile,\n        original: input,\n        generated: output\n    });\n}\n\nSourceMapper.prototype.applySourceMap = function (consumer) {\n    this.generator.applySourceMap(consumer);\n}\n\nSourceMapper.prototype.generate = function () {\n    return this.generator.toString();\n}\n\nfunction compareLoc(a, b) {\n    return (a.line - b.line) || (a.column - b.column);\n}\n\nmodule.exports = function generateSourcemap(result, src, nodePositions, fragments, mapOpts) {\n    const existingMap = convertSourceMap.fromSource(src);\n    const existingMapObject = existingMap && existingMap.toObject();\n    const inFile = (existingMapObject && existingMapObject.file) || mapOpts.inFile || \"source.js\";\n    const sourceRoot = (existingMapObject && existingMapObject.sourceRoot) || mapOpts.sourceRoot;\n    src = convertSourceMap.removeMapFileComments(src);\n\n    const mapper = new SourceMapper(src, nodePositions, fragments, inFile, sourceRoot);\n    mapper.calculateMappings();\n\n    if (mapOpts.inline) {\n        if (existingMapObject)\n            mapper.applySourceMap(new SourceMapConsumer(existingMapObject));\n\n        result.src = convertSourceMap.removeMapFileComments(result.src) +\n            os.EOL +\n            convertSourceMap.fromJSON(mapper.generate()).toComment();\n    } else {\n        result.map = mapper.generate();\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/lut.js":"// lut.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\n\nconst assert = require(\"assert\");\nconst traverse = require(\"ordered-ast-traverse\");\nconst is = require(\"simple-is\");\n\nmodule.exports = Lut;\n\nfunction Lut(ast, src) {\n    assert(this instanceof Lut);\n\n    const sparseBegins = new Array(src.length);\n    const begins = [];\n    const sparseEnds = new Array(src.length);\n    const ends = [];\n    let p = 0;\n    const t0 = Date.now();\n    traverse(ast, {pre: function(node) {\n        //        assert (node.range[0] >= p);\n        if (node.type === \"Program\") {\n            return;\n        }\n        p = node.range[0];\n        if (!sparseBegins[p]) {\n            sparseBegins[p] = node;\n        }\n        p = node.range[1];\n        if (!sparseEnds[p]) {\n            sparseEnds[p] = node;\n        }\n    }});\n    for (let i in sparseBegins) {\n        begins.push(sparseBegins[i]);\n    }\n    for (let i in sparseEnds) {\n        ends.push(sparseEnds[i]);\n    }\n    const t1 = Date.now();\n    //    console.error(t1-t0)\n\n    // begins and ends are compact arrays with nodes,\n    // sorted on node.range[0/1] (unique)\n    this.begins = begins;\n    this.ends = ends;\n}\n\nLut.prototype.findNodeFromPos = findNodeFromPos;\nLut.prototype.findNodeBeforePos = findNodeBeforePos;\n\n// binary search lut to find node beginning at pos\n// or as close after pos as possible. null if none\nfunction findNodeFromPos(pos) {\n    const lut = this.begins;\n    assert(is.finitenumber(pos) && pos >= 0);\n\n    let left = 0;\n    let right = lut.length - 1;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        assert(mid >= 0 && mid < lut.length);\n        if (pos > lut[mid].range[0]) {\n            left = mid + 1;\n        }\n        else {\n            right = mid;\n        }\n    }\n    if (left > right) {\n        assert(last(lut).range[0] < pos);\n        return null;\n    }\n\n    const found = left;\n    const foundPos = lut[found].range[0];\n    assert(foundPos >= pos);\n    if (found >= 1) {\n        const prevPos = lut[found - 1].range[0];\n        assert(prevPos < pos);\n    }\n\n    return lut[found];\n}\n\n// binary search lut to find node ending (as in range[1]\n// at or before pos. null if none\nfunction findNodeBeforePos(pos) {\n    const lut = this.ends;\n    assert(is.finitenumber(pos) && pos >= 0);\n\n    let left = 0;\n    let right = lut.length - 1;\n    while (left < right) {\n        const mid = Math.ceil((left + right) / 2);\n        assert(mid >= 0 && mid < lut.length);\n        if (pos < lut[mid].range[1]) {\n            right = mid - 1;\n        }\n        else {\n            left = mid;\n        }\n    }\n    if (left > right) {\n        assert(lut[0].range[1] > pos);\n        return null;\n    }\n\n    const found = left;\n    const foundPos = lut[found].range[1];\n    if(foundPos > pos) {\n        return null;\n    }\n    if (found <= lut.length - 2) {\n        const nextPos = lut[found + 1].range[1];\n        assert(nextPos > pos);\n    }\n\n    return lut[found];\n}\n\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/ng-annotate.js":"// ng-annotate.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\n\nconst t0 = Date.now();\nconst fs = require(\"fs\");\nconst fmt = require(\"simple-fmt\");\nconst tryor = require(\"tryor\");\nconst ngAnnotate = require(\"./ng-annotate-main\");\nconst version = require(\"./package.json\").version;\nconst optimist = require(\"optimist\")\n    .usage(\"ng-annotate v\" + version + \"\\n\\nUsage: ng-annotate OPTIONS <file>\\n\\n\" +\n        \"provide - instead of <file> to read from stdin\\n\" +\n        \"use -a and -r together to remove and add (rebuild) annotations in one go\")\n    .options(\"a\", {\n        alias: \"add\",\n        boolean: true,\n        describe: \"add dependency injection annotations where non-existing\",\n    })\n    .options(\"r\", {\n        alias: \"remove\",\n        boolean: true,\n        describe: \"remove all existing dependency injection annotations\",\n    })\n    .options(\"o\", {\n        describe: \"write output to <file>. output is written to stdout by default\",\n    })\n    .options(\"sourcemap\", {\n        boolean: true,\n        describe: \"generate an inline sourcemap\"\n    })\n    .options(\"sourceroot\", {\n        describe: \"set the sourceRoot property of the generated sourcemap\"\n    })\n    .options(\"single_quotes\", {\n        boolean: true,\n        describe: \"use single quotes (') instead of double quotes (\\\")\",\n    })\n    .options(\"regexp\", {\n        describe: \"detect short form myMod.controller(...) iff myMod matches regexp\",\n    })\n    .options(\"rename\", {\n        describe: \"rename declarations and annotated references\\n\" +\n            \"oldname1 newname1 oldname2 newname2 ...\",\n        default: \"\"\n    })\n    .options(\"plugin\", {\n        describe: \"use plugin with path (experimental)\",\n    })\n    .options(\"enable\", {\n        describe: \"enable optional with name\",\n    })\n    .options(\"list\", {\n        describe: \"list all optional names\",\n        boolean: true,\n    })\n    .options(\"stats\", {\n        boolean: true,\n        describe: \"print statistics on stderr (experimental)\",\n    });\n\nconst argv = optimist.argv;\n\nfunction exit(msg) {\n    if (msg) {\n        process.stderr.write(msg);\n        process.stderr.write(\"\\n\");\n    }\n    process.exit(-1);\n}\n\n// special-case for --list\nif (argv.list) {\n    const list = ngAnnotate(\"\", {list: true}).list;\n    if (list.length >= 1) {\n        process.stdout.write(list.join(\"\\n\") + \"\\n\");\n    }\n    process.exit(0);\n}\n\n// validate options\nif (argv._.length !== 1) {\n    optimist.showHelp();\n    exit(\"error: no input file provided\");\n}\n\nif (!argv.add && !argv.remove) {\n    optimist.showHelp();\n    exit(\"error: missing option --add and/or --remove\");\n}\n\nconst filename = argv._.shift();\n\n(filename === \"-\" ? slurpStdin : slurpFile)(runAnnotate);\n\n\nfunction slurpStdin(cb) {\n    let buf = \"\";\n\n    process.stdin.setEncoding(\"utf8\");\n    process.stdin.on(\"data\", function(d) {\n        buf += d;\n    });\n    process.stdin.on(\"end\", function() {\n        cb(null, buf);\n    });\n    process.stdin.resume();\n}\n\nfunction slurpFile(cb) {\n    if (!fs.existsSync(filename)) {\n        cb(new Error(fmt('error: file not found {0}', filename)));\n    }\n\n    fs.readFile(filename, cb);\n}\n\nfunction runAnnotate(err, src) {\n    if (err) {\n        exit(err.message);\n    }\n\n    src = String(src);\n\n    const config = tryor(function() {\n        return JSON.parse(String(fs.readFileSync(\"ng-annotate-config.json\")));\n    }, {});\n\n    if (filename !== \"-\") {\n        config.inFile = filename;\n    }\n\n    [\"add\", \"remove\", \"o\", \"regexp\", \"rename\", \"single_quotes\", \"plugin\", \"enable\", \"stats\"].forEach(function(opt) {\n        if (opt in argv) {\n            config[opt] = argv[opt];\n        }\n    });\n\n    if (argv.sourcemap) {\n        config.map = { inline: true, sourceRoot: argv.sourceroot };\n        if (filename !== \"-\") {\n            config.map.inFile = filename;\n        }\n    };\n\n    if (config.enable && !Array.isArray(config.enable)) {\n        config.enable = [config.enable];\n    }\n\n    if (config.plugin) {\n        if (!Array.isArray(config.plugin)) {\n            config.plugin = [config.plugin];\n        }\n        config.plugin = config.plugin.map(function(path) {\n            const absPath = tryor(fs.realpathSync.bind(fs, path), null);\n            if (!absPath) {\n                exit(fmt('error: plugin file not found {0}', path));\n            }\n            // the require below may throw an exception on parse-error\n            try {\n                return require(absPath);\n            } catch (e) {\n                // node will already print file:line and offending line to stderr\n                exit(fmt(\"error: couldn't require(\\\"{0}\\\")\", absPath));\n            }\n        });\n    }\n\n    const trimmedRename = config.rename && config.rename.trim();\n    if (trimmedRename) {\n        const flattenRename = trimmedRename.split(\" \");\n        const renameArray = [];\n        for (let i = 0; i < flattenRename.length; i = i + 2) {\n            renameArray.push({\n                \"from\": flattenRename[i],\n                \"to\": flattenRename[i + 1],\n            });\n        }\n        config.rename = renameArray;\n    } else {\n        config.rename = null;\n    }\n\n    const run_t0 = Date.now();\n    const ret = ngAnnotate(src, config);\n    const run_t1 = Date.now();\n\n    if (ret.errors) {\n        exit(ret.errors.join(\"\\n\"));\n    }\n\n    const stats = ret._stats;\n    if (config.stats && stats) {\n        const t1 = Date.now();\n        const all = t1 - t0;\n        const run_parser = stats.parser_parse_t1 - stats.parser_parse_t0;\n        const all_parser = run_parser + (stats.parser_require_t1 - stats.parser_require_t0);\n        const nga_run = (run_t1 - run_t0) - run_parser;\n        const nga_init = all - all_parser - nga_run;\n\n        const pct = function(n) {\n            return Math.round(100 * n / all);\n        }\n\n        process.stderr.write(fmt(\"[{0} ms] parser: {1}, nga init: {2}, nga run: {3}\\n\", all, all_parser, nga_init, nga_run));\n        process.stderr.write(fmt(\"[%] parser: {0}, nga init: {1}, nga run: {2}\\n\", pct(all_parser), pct(nga_init), pct(nga_run)));\n    }\n\n    if (ret.src && config.o) {\n        try {\n            fs.writeFileSync(config.o, ret.src);\n        } catch (e) {\n            exit(e.message);\n        }\n    } else if (ret.src) {\n        process.stdout.write(ret.src);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/ng-annotate-main.js":"// ng-annotate-main.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\nconst fmt = require(\"simple-fmt\");\nconst is = require(\"simple-is\");\nconst alter = require(\"alter\");\nconst traverse = require(\"ordered-ast-traverse\");\nlet EOL = require(\"os\").EOL;\nconst assert = require(\"assert\");\nconst ngInject = require(\"./nginject\");\nconst generateSourcemap = require(\"./generate-sourcemap\");\nconst Lut = require(\"./lut\");\nconst scopeTools = require(\"./scopetools\");\nconst stringmap = require(\"stringmap\");\nconst optionalAngularDashboardFramework = require(\"./optionals/angular-dashboard-framework\");\nconst require_acorn_t0 = Date.now();\nconst parser = require(\"acorn\").parse;\nconst require_acorn_t1 = Date.now();\n\nconst chainedRouteProvider = 1;\nconst chainedUrlRouterProvider = 2;\nconst chainedStateProvider = 3;\nconst chainedRegular = 4;\n\nfunction match(node, ctx, matchPlugins) {\n    const isMethodCall = (\n        node.type === \"CallExpression\" &&\n            node.callee.type === \"MemberExpression\" &&\n            node.callee.computed === false\n        );\n\n    // matchInjectorInvoke must happen before matchRegular\n    // to prevent false positive ($injector.invoke() outside module)\n    // matchProvide must happen before matchRegular\n    // to prevent regular from matching it as a short-form\n    const matchMethodCalls = (isMethodCall &&\n        (matchInjectorInvoke(node) || matchProvide(node, ctx) || matchRegular(node, ctx) || matchNgRoute(node) || matchMaterialShowModalOpen(node) || matchNgUi(node) || matchHttpProvider(node) || matchControllerProvider(node)));\n\n    return matchMethodCalls ||\n        (matchPlugins && matchPlugins(node)) ||\n        matchDirectiveReturnObject(node) ||\n        matchProviderGet(node);\n}\n\nfunction matchMaterialShowModalOpen(node) {\n    // $mdDialog.show({.. controller: fn, resolve: {f: function($scope) {}, ..}});\n    // $mdToast.show({.. controller: fn, resolve: {f: function($scope) {}, ..}});\n    // $mdBottomSheet.show({.. controller: fn, resolve: {f: function($scope) {}, ..}});\n    // $modal.open({.. controller: fn, resolve: {f: function($scope) {}, ..}});\n\n    // we already know that node is a (non-computed) method call\n    const callee = node.callee;\n    const obj = callee.object; // identifier or expression\n    const method = callee.property; // identifier\n    const args = node.arguments;\n\n    if (obj.type === \"Identifier\" &&\n        ((is.someof(obj.name, [\"$modal\", \"$uibModal\"]) && method.name === \"open\") || (is.someof(obj.name, [\"$mdDialog\", \"$mdToast\", \"$mdBottomSheet\"]) && method.name === \"show\")) &&\n        args.length === 1 && args[0].type === \"ObjectExpression\") {\n        const props = args[0].properties;\n        const res = [matchProp(\"controller\", props)];\n        res.push.apply(res, matchResolve(props));\n        return res.filter(Boolean);\n    }\n    return false;\n}\n\nfunction matchDirectiveReturnObject(node) {\n    // only matches inside directives\n    // return { .. controller: function($scope, $timeout), ...}\n\n    return limit(\"directive\", node.type === \"ReturnStatement\" &&\n        node.argument && node.argument.type === \"ObjectExpression\" &&\n        matchProp(\"controller\", node.argument.properties));\n}\n\nfunction limit(name, node) {\n    if (node && !node.$limitToMethodName) {\n        node.$limitToMethodName = name;\n    }\n    return node;\n}\n\nfunction matchProviderGet(node) {\n    // only matches inside providers\n    // (this|self|that).$get = function($scope, $timeout)\n    // { ... $get: function($scope, $timeout), ...}\n    let memberExpr;\n    let self;\n    return limit(\"provider\", (node.type === \"AssignmentExpression\" && (memberExpr = node.left).type === \"MemberExpression\" &&\n        memberExpr.property.name === \"$get\" &&\n        ((self = memberExpr.object).type === \"ThisExpression\" || (self.type === \"Identifier\" && is.someof(self.name, [\"self\", \"that\"]))) &&\n        node.right) ||\n        (node.type === \"ObjectExpression\" && matchProp(\"$get\", node.properties)));\n}\n\nfunction matchNgRoute(node) {\n    // $routeProvider.when(\"path\", {\n    //   ...\n    //   controller: function($scope) {},\n    //   resolve: {f: function($scope) {}, ..}\n    // })\n\n    // we already know that node is a (non-computed) method call\n    const callee = node.callee;\n    const obj = callee.object; // identifier or expression\n    if (!(obj.$chained === chainedRouteProvider || (obj.type === \"Identifier\" && obj.name === \"$routeProvider\"))) {\n        return false;\n    }\n    node.$chained = chainedRouteProvider;\n\n    const method = callee.property; // identifier\n    if (method.name !== \"when\") {\n        return false;\n    }\n\n    const args = node.arguments;\n    if (args.length !== 2) {\n        return false;\n    }\n    const configArg = last(args)\n    if (configArg.type !== \"ObjectExpression\") {\n        return false;\n    }\n\n    const props = configArg.properties;\n    const res = [\n        matchProp(\"controller\", props)\n    ];\n    // {resolve: ..}\n    res.push.apply(res, matchResolve(props));\n\n    const filteredRes = res.filter(Boolean);\n    return (filteredRes.length === 0 ? false : filteredRes);\n}\n\nfunction matchNgUi(node) {\n    // $stateProvider.state(\"myState\", {\n    //     ...\n    //     controller: function($scope)\n    //     controllerProvider: function($scope)\n    //     templateProvider: function($scope)\n    //     onEnter: function($scope)\n    //     onExit: function($scope)\n    // });\n    // $stateProvider.state(\"myState\", {... resolve: {f: function($scope) {}, ..} ..})\n    // $stateProvider.state(\"myState\", {... params: {params: {simple: function($scope) {}, inValue: { value: function($scope) {} }} ..})\n    // $stateProvider.state(\"myState\", {... views: {... somename: {... controller: fn, controllerProvider: fn, templateProvider: fn, resolve: {f: fn}}}})\n    //\n    // stateHelperProvider.setNestedState({ sameasregularstate, children: [sameasregularstate, ..]})\n    // stateHelperProvider.setNestedState({ sameasregularstate, children: [sameasregularstate, ..]}, true)\n    //\n    // $urlRouterProvider.when(.., function($scope) {})\n    //\n    // $modal.open see matchMaterialShowModalOpen\n\n    // we already know that node is a (non-computed) method call\n    const callee = node.callee;\n    const obj = callee.object; // identifier or expression\n    const method = callee.property; // identifier\n    const args = node.arguments;\n\n    // shortcut for $urlRouterProvider.when(.., function($scope) {})\n    if (obj.$chained === chainedUrlRouterProvider || (obj.type === \"Identifier\" && obj.name === \"$urlRouterProvider\")) {\n        node.$chained = chainedUrlRouterProvider;\n\n        if (method.name === \"when\" && args.length >= 1) {\n            return last(args);\n        }\n        return false;\n    }\n\n    // everything below is for $stateProvider and stateHelperProvider alone\n    if (!(obj.$chained === chainedStateProvider || (obj.type === \"Identifier\" && is.someof(obj.name, [\"$stateProvider\", \"stateHelperProvider\"])))) {\n        return false;\n    }\n    node.$chained = chainedStateProvider;\n\n    if (is.noneof(method.name, [\"state\", \"setNestedState\"])) {\n        return false;\n    }\n\n    // $stateProvider.state({ ... }) and $stateProvider.state(\"name\", { ... })\n    // stateHelperProvider.setNestedState({ .. }) and stateHelperProvider.setNestedState({ .. }, true)\n    if (!(args.length >= 1 && args.length <= 2)) {\n        return false;\n    }\n\n    const configArg = (method.name === \"state\" ? last(args) : args[0]);\n\n    const res = [];\n\n    recursiveMatch(configArg);\n\n    const filteredRes = res.filter(Boolean);\n    return (filteredRes.length === 0 ? false : filteredRes);\n\n\n    function recursiveMatch(objectExpressionNode) {\n        if (!objectExpressionNode || objectExpressionNode.type !== \"ObjectExpression\") {\n            return false;\n        }\n\n        const properties = objectExpressionNode.properties;\n\n        matchStateProps(properties, res);\n\n        const childrenArrayExpression = matchProp(\"children\", properties);\n        const children = childrenArrayExpression && childrenArrayExpression.elements;\n\n        if (!children) {\n            return;\n        }\n        children.forEach(recursiveMatch);\n    }\n\n    function matchStateProps(props, res) {\n        const simple = [\n            matchProp(\"controller\", props),\n            matchProp(\"controllerProvider\", props),\n            matchProp(\"templateProvider\", props),\n            matchProp(\"onEnter\", props),\n            matchProp(\"onExit\", props),\n        ];\n        res.push.apply(res, simple);\n\n        // {resolve: ..}\n        res.push.apply(res, matchResolve(props));\n\n        // {params: {simple: function($scope) {}, inValue: { value: function($scope) {} }}\n        const a = matchProp(\"params\", props);\n        if (a && a.type === \"ObjectExpression\") {\n            a.properties.forEach(function(prop) {\n                if (prop.value.type === \"ObjectExpression\") {\n                    res.push(matchProp(\"value\", prop.value.properties));\n                } else {\n                    res.push(prop.value);\n                }\n            });\n        }\n\n        // {view: ...}\n        const viewObject = matchProp(\"views\", props);\n        if (viewObject && viewObject.type === \"ObjectExpression\") {\n            viewObject.properties.forEach(function(prop) {\n                if (prop.value.type === \"ObjectExpression\") {\n                    res.push(matchProp(\"controller\", prop.value.properties));\n                    res.push(matchProp(\"controllerProvider\", prop.value.properties));\n                    res.push(matchProp(\"templateProvider\", prop.value.properties));\n                    res.push.apply(res, matchResolve(prop.value.properties));\n                }\n            });\n        }\n    }\n}\n\nfunction matchInjectorInvoke(node) {\n    // $injector.invoke(function($compile) { ... });\n\n    // we already know that node is a (non-computed) method call\n    const callee = node.callee;\n    const obj = callee.object; // identifier or expression\n    const method = callee.property; // identifier\n\n    return method.name === \"invoke\" &&\n        obj.type === \"Identifier\" && obj.name === \"$injector\" &&\n        node.arguments.length >= 1 && node.arguments;\n}\n\nfunction matchHttpProvider(node) {\n    // $httpProvider.interceptors.push(function($scope) {});\n    // $httpProvider.responseInterceptors.push(function($scope) {});\n\n    // we already know that node is a (non-computed) method call\n    const callee = node.callee;\n    const obj = callee.object; // identifier or expression\n    const method = callee.property; // identifier\n\n    return (method.name === \"push\" &&\n        obj.type === \"MemberExpression\" && !obj.computed &&\n        obj.object.name === \"$httpProvider\" && is.someof(obj.property.name,  [\"interceptors\", \"responseInterceptors\"]) &&\n        node.arguments.length >= 1 && node.arguments);\n}\n\nfunction matchControllerProvider(node) {\n    // $controllerProvider.register(\"foo\", function($scope) {});\n\n    // we already know that node is a (non-computed) method call\n    const callee = node.callee;\n    const obj = callee.object; // identifier or expression\n    const method = callee.property; // identifier\n    const args = node.arguments;\n\n    const target = obj.type === \"Identifier\" && obj.name === \"$controllerProvider\" &&\n        method.name === \"register\" && args.length === 2 && args[1];\n\n    if (target) {\n        target.$methodName = method.name;\n    }\n    return target;\n}\n\nfunction matchProvide(node, ctx) {\n    // $provide.decorator(\"foo\", function($scope) {});\n    // $provide.service(\"foo\", function($scope) {});\n    // $provide.factory(\"foo\", function($scope) {});\n    // $provide.provider(\"foo\", function($scope) {});\n\n    // we already know that node is a (non-computed) method call\n    const callee = node.callee;\n    const obj = callee.object; // identifier or expression\n    const method = callee.property; // identifier\n    const args = node.arguments;\n\n    const target = obj.type === \"Identifier\" && obj.name === \"$provide\" &&\n        is.someof(method.name, [\"decorator\", \"service\", \"factory\", \"provider\"]) &&\n        args.length === 2 && args[1];\n\n    if (target) {\n        target.$methodName = method.name;\n\n        if (ctx.rename) {\n            // for eventual rename purposes\n            return args;\n        }\n    }\n    return target;\n}\n\nfunction matchRegular(node, ctx) {\n    // we already know that node is a (non-computed) method call\n    const callee = node.callee;\n    const obj = callee.object; // identifier or expression\n    const method = callee.property; // identifier\n\n    // short-cut implicit config special case:\n    // angular.module(\"MyMod\", function(a) {})\n    if (obj.name === \"angular\" && method.name === \"module\") {\n        const args = node.arguments;\n        if (args.length >= 2) {\n            node.$chained = chainedRegular;\n            return last(args);\n        }\n    }\n\n    // hardcoded exception: foo.decorator is generally considered a short-form\n    // declaration but $stateProvider.decorator is not. see https://github.com/olov/ng-annotate/issues/82\n    if (obj.name === \"$stateProvider\" && method.name === \"decorator\") {\n        return false;\n    }\n\n    const matchAngularModule = (obj.$chained === chainedRegular || isReDef(obj, ctx) || isLongDef(obj)) &&\n        is.someof(method.name, [\"provider\", \"value\", \"constant\", \"bootstrap\", \"config\", \"factory\", \"directive\", \"filter\", \"run\", \"controller\", \"service\", \"animation\", \"invoke\", \"store\", \"decorator\", \"component\"]);\n    if (!matchAngularModule) {\n        return false;\n    }\n    node.$chained = chainedRegular;\n\n    if (is.someof(method.name, [\"value\", \"constant\", \"bootstrap\"])) {\n        return false; // affects matchAngularModule because of chaining\n    }\n\n    const args = node.arguments;\n    let target = (is.someof(method.name, [\"config\", \"run\"]) ?\n        args.length === 1 && args[0] :\n        args.length === 2 && args[0].type === \"Literal\" && is.string(args[0].value) && args[1]);\n\n    if (method.name === \"component\") {\n        const controllerProp = (target && target.type === \"ObjectExpression\" && matchProp(\"controller\", target.properties));\n        if (!controllerProp) {\n            return false;\n        }\n        target = controllerProp;\n    }\n\n    if (target) {\n        target.$methodName = method.name;\n    }\n\n    if (ctx.rename && args.length === 2 && target) {\n        // for eventual rename purposes\n        const somethingNameLiteral = args[0];\n        return [somethingNameLiteral, target];\n    }\n    return target;\n}\n\n// matches with default regexp\n//   *.controller(\"MyCtrl\", function($scope, $timeout) {});\n//   *.*.controller(\"MyCtrl\", function($scope, $timeout) {});\n// matches with --regexp \"^require(.*)$\"\n//   require(\"app-module\").controller(\"MyCtrl\", function($scope) {});\nfunction isReDef(node, ctx) {\n    return ctx.re.test(ctx.srcForRange(node.range));\n}\n\n// Long form: angular.module(*).controller(\"MyCtrl\", function($scope, $timeout) {});\nfunction isLongDef(node) {\n    return node.callee &&\n        node.callee.object && node.callee.object.name === \"angular\" &&\n        node.callee.property && node.callee.property.name === \"module\";\n}\n\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction matchProp(name, props) {\n    for (let i = 0; i < props.length; i++) {\n        const prop = props[i];\n        if ((prop.key.type === \"Identifier\" && prop.key.name === name) ||\n            (prop.key.type === \"Literal\" && prop.key.value === name)) {\n            return prop.value; // FunctionExpression or ArrayExpression\n        }\n    }\n    return null;\n}\n\nfunction matchResolve(props) {\n    const resolveObject = matchProp(\"resolve\", props);\n    if (resolveObject && resolveObject.type === \"ObjectExpression\") {\n        return resolveObject.properties.map(function(prop) {\n            return prop.value;\n        });\n    }\n    return [];\n};\n\nfunction renamedString(ctx, originalString) {\n    if (ctx.rename) {\n        return ctx.rename.get(originalString) || originalString;\n    }\n    return originalString;\n}\n\nfunction stringify(ctx, arr, quot) {\n    return \"[\" + arr.map(function(arg) {\n        return quot + renamedString(ctx, arg.name) + quot;\n    }).join(\", \") + \"]\";\n}\n\nfunction parseExpressionOfType(str, type) {\n    const node = parser(str).body[0].expression;\n    assert(node.type === type);\n    return node;\n}\n\n// stand-in for not having a jsshaper-style ref's\nfunction replaceNodeWith(node, newNode) {\n    let done = false;\n    const parent = node.$parent;\n    const keys = Object.keys(parent);\n    keys.forEach(function(key) {\n        if (parent[key] === node) {\n            parent[key] = newNode;\n            done = true;\n        }\n    });\n\n    if (done) {\n        return;\n    }\n\n    // second pass, now check arrays\n    keys.forEach(function(key) {\n        if (Array.isArray(parent[key])) {\n            const arr = parent[key];\n            for (let i = 0; i < arr.length; i++) {\n                if (arr[i] === node) {\n                    arr[i] = newNode;\n                    done = true;\n                }\n            }\n        }\n    });\n\n    assert(done);\n}\n\nfunction insertArray(ctx, functionExpression, fragments, quot) {\n    const args = stringify(ctx, functionExpression.params, quot);\n\n    fragments.push({\n        start: functionExpression.range[0],\n        end: functionExpression.range[0],\n        str: args.slice(0, -1) + \", \",\n        loc: {\n            start: functionExpression.loc.start,\n            end: functionExpression.loc.start\n        }\n    });\n    fragments.push({\n        start: functionExpression.range[1],\n        end: functionExpression.range[1],\n        str: \"]\",\n        loc: {\n            start: functionExpression.loc.end,\n            end: functionExpression.loc.end\n        }\n    });\n}\n\nfunction replaceArray(ctx, array, fragments, quot) {\n    const functionExpression = last(array.elements);\n\n    if (functionExpression.params.length === 0) {\n        return removeArray(array, fragments);\n    }\n\n    const args = stringify(ctx, functionExpression.params, quot);\n    fragments.push({\n        start: array.range[0],\n        end: functionExpression.range[0],\n        str: args.slice(0, -1) + \", \",\n        loc: {\n            start: array.loc.start,\n            end: functionExpression.loc.start\n        }\n    });\n}\n\nfunction removeArray(array, fragments) {\n    const functionExpression = last(array.elements);\n\n    fragments.push({\n        start: array.range[0],\n        end: functionExpression.range[0],\n        str: \"\",\n        loc: {\n            start: array.loc.start,\n            end: functionExpression.loc.start\n        }\n    });\n    fragments.push({\n        start: functionExpression.range[1],\n        end: array.range[1],\n        str: \"\",\n        loc: {\n            start: functionExpression.loc.end,\n            end: array.loc.end\n        }\n    });\n}\n\nfunction renameProviderDeclarationSite(ctx, literalNode, fragments) {\n    fragments.push({\n        start: literalNode.range[0] + 1,\n        end: literalNode.range[1] - 1,\n        str: renamedString(ctx, literalNode.value),\n        loc: {\n            start: {\n                line: literalNode.loc.start.line,\n                column: literalNode.loc.start.column + 1\n            }, end: {\n                line: literalNode.loc.end.line,\n                column: literalNode.loc.end.column - 1\n            }\n        }\n    });\n}\n\nfunction judgeSuspects(ctx) {\n    const mode = ctx.mode;\n    const fragments = ctx.fragments;\n    const quot = ctx.quot;\n    const blocked = ctx.blocked;\n\n    const suspects = makeUnique(ctx.suspects, 1);\n\n    for (let n = 0; n < 42; n++) {\n        // could be while(true), above is just a safety-net\n        // in practice it will loop just a couple of times\n        propagateModuleContextAndMethodName(suspects);\n        if (!setChainedAndMethodNameThroughIifesAndReferences(suspects)) {\n            break;\n        }\n    }\n\n    // create final suspects by jumping, following, uniq'ing, blocking\n    const finalSuspects = makeUnique(suspects.map(function(target) {\n        const jumped = jumpOverIife(target);\n        const jumpedAndFollowed = followReference(jumped) || jumped;\n\n        if (target.$limitToMethodName && target.$limitToMethodName !== \"*never*\" && findOuterMethodName(target) !== target.$limitToMethodName) {\n            return null;\n        }\n\n        if (blocked.indexOf(jumpedAndFollowed) >= 0) {\n            return null;\n        }\n\n        return jumpedAndFollowed;\n    }).filter(Boolean), 2);\n\n    finalSuspects.forEach(function(target) {\n        if (target.$chained !== chainedRegular) {\n            return;\n        }\n\n        if (mode === \"rebuild\" && isAnnotatedArray(target)) {\n            replaceArray(ctx, target, fragments, quot);\n        } else if (mode === \"remove\" && isAnnotatedArray(target)) {\n            removeArray(target, fragments);\n        } else if (is.someof(mode, [\"add\", \"rebuild\"]) && isFunctionExpressionWithArgs(target)) {\n            insertArray(ctx, target, fragments, quot);\n        } else if (isGenericProviderName(target)) {\n            renameProviderDeclarationSite(ctx, target, fragments);\n        } else {\n            // if it's not array or function-expression, then it's a candidate for foo.$inject = [..]\n            judgeInjectArraySuspect(target, ctx);\n        }\n    });\n\n\n    function propagateModuleContextAndMethodName(suspects) {\n        suspects.forEach(function(target) {\n            if (target.$chained !== chainedRegular && isInsideModuleContext(target)) {\n                target.$chained = chainedRegular;\n            }\n\n            if (!target.$methodName) {\n                const methodName = findOuterMethodName(target);\n                if (methodName) {\n                    target.$methodName = methodName;\n                }\n            }\n        });\n    }\n\n    function findOuterMethodName(node) {\n        for (; node && !node.$methodName; node = node.$parent) {\n        }\n        return node ? node.$methodName : null;\n    }\n\n    function setChainedAndMethodNameThroughIifesAndReferences(suspects) {\n        let modified = false;\n        suspects.forEach(function(target) {\n            const jumped = jumpOverIife(target);\n            if (jumped !== target) { // we did skip an IIFE\n                if (target.$chained === chainedRegular && jumped.$chained !== chainedRegular) {\n                    modified = true;\n                    jumped.$chained = chainedRegular;\n                }\n                if (target.$methodName && !jumped.$methodName) {\n                    modified = true;\n                    jumped.$methodName = target.$methodName;\n                }\n            }\n\n            const jumpedAndFollowed = followReference(jumped) || jumped;\n            if (jumpedAndFollowed !== jumped) { // we did follow a reference\n                if (jumped.$chained === chainedRegular && jumpedAndFollowed.$chained !== chainedRegular) {\n                    modified = true;\n                    jumpedAndFollowed.$chained = chainedRegular;\n                }\n                if (jumped.$methodName && !jumpedAndFollowed.$methodName) {\n                    modified = true;\n                    jumpedAndFollowed.$methodName = jumped.$methodName;\n                }\n            }\n        });\n        return modified;\n    }\n\n    function isInsideModuleContext(node) {\n        let $parent = node.$parent;\n        for (; $parent && $parent.$chained !== chainedRegular; $parent = $parent.$parent) {\n        }\n        return Boolean($parent);\n    }\n\n    function makeUnique(suspects, val) {\n        return suspects.filter(function(target) {\n            if (target.$seen === val) {\n                return false;\n            }\n            target.$seen = val;\n            return true;\n        });\n    }\n}\n\nfunction followReference(node) {\n    if (!scopeTools.isReference(node)) {\n        return null;\n    }\n\n    const scope = node.$scope.lookup(node.name);\n    if (!scope) {\n        return null;\n    }\n\n    const parent = scope.getNode(node.name).$parent;\n    const kind = scope.getKind(node.name);\n    if (!parent) {\n        return null;\n    }\n    const ptype = parent.type;\n\n    if (is.someof(kind, [\"const\", \"let\", \"var\"])) {\n        assert(ptype === \"VariableDeclarator\");\n        // {type: \"VariableDeclarator\", id: {type: \"Identifier\", name: \"foo\"}, init: ..}\n        return parent;\n    } else if (kind === \"fun\") {\n        assert(ptype === \"FunctionDeclaration\" || ptype === \"FunctionExpression\")\n        // FunctionDeclaration is the common case, i.e.\n        // function foo(a, b) {}\n\n        // FunctionExpression is only applicable for cases similar to\n        // var f = function asdf(a,b) { mymod.controller(\"asdf\", asdf) };\n        return parent;\n    }\n\n    // other kinds should not be handled (\"param\", \"caught\")\n\n    return null;\n}\n\n// O(srclength) so should only be used for debugging purposes, else replace with lut\nfunction posToLine(pos, src) {\n    if (pos >= src.length) {\n        pos = src.length - 1;\n    }\n\n    if (pos <= -1) {\n        return -1;\n    }\n\n    let line = 1;\n    for (let i = 0; i < pos; i++) {\n        if (src[i] === \"\\n\") {\n            ++line;\n        }\n    }\n\n    return line;\n}\n\nfunction firstNonPrologueStatement(body) {\n    for (let i = 0; i < body.length; i++) {\n        if (body[i].type !== \"ExpressionStatement\") {\n            return body[i];\n        }\n\n        const expr = body[i].expression;\n        const isStringLiteral = (expr.type === \"Literal\" && typeof expr.value === \"string\");\n        if (!isStringLiteral) {\n            return body[i];\n        }\n    }\n    return null;\n}\n\nfunction judgeInjectArraySuspect(node, ctx) {\n    if (node.type === \"VariableDeclaration\") {\n        // suspect can only be a VariableDeclaration (statement) in case of\n        // explicitly marked via /*@ngInject*/, not via references because\n        // references follow to VariableDeclarator (child)\n\n        // /*@ngInject*/ var foo = function($scope) {} and\n\n        if (node.declarations.length !== 1) {\n            // more than one declarator => exit\n            return;\n        }\n\n        // one declarator => jump over declaration into declarator\n        // rest of code will treat it as any (referenced) declarator\n        node = node.declarations[0];\n    }\n\n    // onode is a top-level node (inside function block), later verified\n    // node is inner match, descent in multiple steps\n    let onode = null;\n    let declaratorName = null;\n    if (node.type === \"VariableDeclarator\") {\n        onode = node.$parent;\n        declaratorName = node.id.name;\n        node = node.init; // var foo = ___;\n    } else {\n        onode = node;\n    }\n\n    // suspect must be inside of a block or at the top-level (i.e. inside of node.$parent.body[])\n    if (!node || !onode.$parent || is.noneof(onode.$parent.type, [\"Program\", \"BlockStatement\"])) {\n        return;\n    }\n\n    const insertPos = {\n        pos: onode.range[1],\n        loc: onode.loc.end\n    };\n    const isSemicolonTerminated = (ctx.src[insertPos.pos - 1] === \";\");\n\n    node = jumpOverIife(node);\n\n    if (ctx.isFunctionExpressionWithArgs(node)) {\n        // var x = 1, y = function(a,b) {}, z;\n\n        assert(declaratorName);\n        addRemoveInjectArray(\n            node.params,\n            isSemicolonTerminated ? insertPos : {\n                pos: node.range[1],\n                loc: node.loc.end\n            },\n            declaratorName);\n\n    } else if (ctx.isFunctionDeclarationWithArgs(node)) {\n        // /*@ngInject*/ function foo($scope) {}\n\n        addRemoveInjectArray(\n            node.params,\n            insertPos,\n            node.id.name);\n\n    } else if (node.type === \"ExpressionStatement\" && node.expression.type === \"AssignmentExpression\" &&\n        ctx.isFunctionExpressionWithArgs(node.expression.right)) {\n        // /*@ngInject*/ foo.bar[0] = function($scope) {}\n\n        const name = ctx.srcForRange(node.expression.left.range);\n        addRemoveInjectArray(\n            node.expression.right.params,\n            isSemicolonTerminated ? insertPos : {\n                pos: node.expression.right.range[1],\n                loc: node.expression.right.loc.end\n            },\n            name);\n\n    } else if (node = followReference(node)) {\n        // node was a reference and followed node now is either a\n        // FunctionDeclaration or a VariableDeclarator\n        // => recurse\n\n        judgeInjectArraySuspect(node, ctx);\n    }\n\n\n    function getIndent(pos) {\n        const src = ctx.src;\n        const lineStart = src.lastIndexOf(\"\\n\", pos - 1) + 1;\n        let i = lineStart;\n        for (; src[i] === \" \" || src[i] === \"\\t\"; i++) {\n        }\n        return src.slice(lineStart, i);\n    }\n\n    function addRemoveInjectArray(params, posAfterFunctionDeclaration, name) {\n        // if an existing something.$inject = [..] exists then is will always be recycled when rebuilding\n\n        const indent = getIndent(posAfterFunctionDeclaration.pos);\n\n        let foundSuspectInBody = false;\n        let existingExpressionStatementWithArray = null;\n        let nodeAfterExtends = null;\n        onode.$parent.body.forEach(function(bnode, idx) {\n            if (bnode === onode) {\n                foundSuspectInBody = true;\n            }\n\n            if (hasInjectArray(bnode)) {\n                if (existingExpressionStatementWithArray) {\n                    throw fmt(\"conflicting inject arrays at line {0} and {1}\",\n                        posToLine(existingExpressionStatementWithArray.range[0], ctx.src),\n                        posToLine(bnode.range[0], ctx.src));\n                }\n                existingExpressionStatementWithArray = bnode;\n            }\n\n            let e;\n            if (!nodeAfterExtends && !foundSuspectInBody && bnode.type === \"ExpressionStatement\" && (e = bnode.expression).type === \"CallExpression\" && e.callee.type === \"Identifier\" && e.callee.name === \"__extends\") {\n                const nextStatement = onode.$parent.body[idx + 1];\n                if (nextStatement) {\n                    nodeAfterExtends = nextStatement;\n                }\n            }\n        });\n        assert(foundSuspectInBody);\n        if (onode.type === \"FunctionDeclaration\") {\n            if (!nodeAfterExtends) {\n                nodeAfterExtends = firstNonPrologueStatement(onode.$parent.body);\n            }\n            if (nodeAfterExtends && !existingExpressionStatementWithArray) {\n                posAfterFunctionDeclaration = skipPrevNewline(nodeAfterExtends.range[0], nodeAfterExtends.loc.start);\n            }\n        }\n\n        function hasInjectArray(node) {\n            let lvalue;\n            let assignment;\n            return (node && node.type === \"ExpressionStatement\" && (assignment = node.expression).type === \"AssignmentExpression\" &&\n                assignment.operator === \"=\" &&\n                (lvalue = assignment.left).type === \"MemberExpression\" &&\n                ((lvalue.computed === false && ctx.srcForRange(lvalue.object.range) === name && lvalue.property.name === \"$inject\") ||\n                    (lvalue.computed === true && ctx.srcForRange(lvalue.object.range) === name && lvalue.property.type === \"Literal\" && lvalue.property.value === \"$inject\")));\n        }\n\n        function skipPrevNewline(pos, loc) {\n            let prevLF = ctx.src.lastIndexOf(\"\\n\", pos);\n            if (prevLF === -1) {\n                return { pos: pos, loc: loc };\n            }\n            if (prevLF >= 1 && ctx.src[prevLF - 1] === \"\\r\") {\n                --prevLF;\n            }\n\n            if (/\\S/g.test(ctx.src.slice(prevLF, pos - 1))) { // any non-whitespace chars between prev newline and pos?\n                return { pos: pos, loc: loc };\n            }\n\n            return {\n                pos: prevLF,\n                loc: {\n                    line: loc.line - 1,\n                    column: prevLF - ctx.src.lastIndexOf(\"\\n\", prevLF) - 1,\n                }\n            };\n        }\n\n        if (ctx.mode === \"rebuild\" && existingExpressionStatementWithArray) {\n            const strNoWhitespace = fmt(\"{2}.$inject = {3};\", null, null, name, ctx.stringify(ctx, params, ctx.quot));\n            ctx.fragments.push({\n                start: existingExpressionStatementWithArray.range[0],\n                end: existingExpressionStatementWithArray.range[1],\n                str: strNoWhitespace,\n                loc: {\n                    start: existingExpressionStatementWithArray.loc.start,\n                    end: existingExpressionStatementWithArray.loc.end\n                }\n            });\n        } else if (ctx.mode === \"remove\" && existingExpressionStatementWithArray) {\n            const start = skipPrevNewline(existingExpressionStatementWithArray.range[0], existingExpressionStatementWithArray.loc.start);\n            ctx.fragments.push({\n                start: start.pos,\n                end: existingExpressionStatementWithArray.range[1],\n                str: \"\",\n                loc: {\n                    start: start.loc,\n                    end: existingExpressionStatementWithArray.loc.end\n                }\n            });\n        } else if (is.someof(ctx.mode, [\"add\", \"rebuild\"]) && !existingExpressionStatementWithArray) {\n            const str = fmt(\"{0}{1}{2}.$inject = {3};\", EOL, indent, name, ctx.stringify(ctx, params, ctx.quot));\n            ctx.fragments.push({\n                start: posAfterFunctionDeclaration.pos,\n                end: posAfterFunctionDeclaration.pos,\n                str: str,\n                loc: {\n                    start: posAfterFunctionDeclaration.loc,\n                    end: posAfterFunctionDeclaration.loc\n                }\n            });\n        }\n    }\n}\n\nfunction jumpOverIife(node) {\n    let outerfn;\n    if (!(node.type === \"CallExpression\" && (outerfn = node.callee).type === \"FunctionExpression\")) {\n        return node;\n    }\n\n    const outerbody = outerfn.body.body;\n    for (let i = 0; i < outerbody.length; i++) {\n        const statement = outerbody[i];\n        if (statement.type === \"ReturnStatement\") {\n            return statement.argument;\n        }\n    }\n\n    return node;\n}\n\nfunction addModuleContextDependentSuspect(target, ctx) {\n    ctx.suspects.push(target);\n}\n\nfunction addModuleContextIndependentSuspect(target, ctx) {\n    target.$chained = chainedRegular;\n    ctx.suspects.push(target);\n}\n\nfunction isAnnotatedArray(node) {\n    if (node.type !== \"ArrayExpression\") {\n        return false;\n    }\n    const elements = node.elements;\n\n    // last should be a function expression\n    if (elements.length === 0 || last(elements).type !== \"FunctionExpression\") {\n        return false;\n    }\n\n    // all but last should be string literals\n    for (let i = 0; i < elements.length - 1; i++) {\n        const n = elements[i];\n        if (n.type !== \"Literal\" || !is.string(n.value)) {\n            return false;\n        }\n    }\n\n    return true;\n}\nfunction isFunctionExpressionWithArgs(node) {\n    return node.type === \"FunctionExpression\" && node.params.length >= 1;\n}\nfunction isFunctionDeclarationWithArgs(node) {\n    return node.type === \"FunctionDeclaration\" && node.params.length >= 1;\n}\nfunction isGenericProviderName(node) {\n    return node.type === \"Literal\" && is.string(node.value);\n}\n\nfunction uniqifyFragments(fragments) {\n    // must do in-place modification of ctx.fragments because shared reference\n\n    const map = Object.create(null);\n    for (let i = 0; i < fragments.length; i++) {\n        const frag = fragments[i];\n        const str = JSON.stringify({start: frag.start, end: frag.end, str: frag.str});\n        if (map[str]) {\n            fragments.splice(i, 1); // remove\n            i--;\n        } else {\n            map[str] = true;\n        }\n    }\n}\n\nconst allOptionals ={\n    \"angular-dashboard-framework\": optionalAngularDashboardFramework,\n};\n\nmodule.exports = function ngAnnotate(src, options) {\n    if (options.list) {\n        return {\n            list: Object.keys(allOptionals).sort(),\n        };\n    }\n\n    const mode = (options.add && options.remove ? \"rebuild\" :\n        options.remove ? \"remove\" :\n            options.add ? \"add\" : null);\n\n    if (!mode) {\n        return {src: src};\n    }\n\n    const quot = options.single_quotes ? \"'\" : '\"';\n    const re = (options.regexp ? new RegExp(options.regexp) : /^[a-zA-Z0-9_\\$\\.\\s]+$/);\n    const rename = new stringmap();\n    if (options.rename) {\n        options.rename.forEach(function(value) {\n            rename.set(value.from, value.to);\n        });\n    }\n    let ast;\n    const stats = {};\n\n    // detect newline and override os.EOL\n    const lf = src.lastIndexOf(\"\\n\");\n    if (lf >= 1) {\n        EOL = (src[lf - 1] === \"\\r\" ? \"\\r\\n\" : \"\\n\");\n    }\n\n    // [{type: \"Block\"|\"Line\", value: str, range: [from,to]}, ..]\n    let comments = [];\n\n    try {\n        stats.parser_require_t0 = require_acorn_t0;\n        stats.parser_require_t1 = require_acorn_t1;\n        stats.parser_parse_t0 = Date.now();\n        // acorn\n        ast = parser(src, {\n            ecmaVersion: 6,\n            allowReserved: true,\n            locations: true,\n            ranges: true,\n            onComment: comments,\n        });\n        stats.parser_parse_t1 = Date.now();\n    } catch(e) {\n        return {\n            errors: [\"error: couldn't process source due to parse error\", e.message],\n        };\n    }\n\n    // append a dummy-node to ast so that lut.findNodeFromPos(lastPos) returns something\n    ast.body.push({\n        type: \"DebuggerStatement\",\n        range: [ast.range[1], ast.range[1]],\n        loc: {\n            start: ast.loc.end,\n            end: ast.loc.end\n        }\n    });\n\n    // all source modifications are built up as operations in the\n    // fragments array, later sent to alter in one shot\n    const fragments = [];\n\n    // suspects is built up with suspect nodes by match.\n    // A suspect node will get annotations added / removed if it\n    // fulfills the arrayexpression or functionexpression look,\n    // and if it is in the correct context (inside an angular\n    // module definition)\n    const suspects = [];\n\n    // blocked is an array of blocked suspects. Any target node\n    // (final, i.e. IIFE-jumped, reference-followed and such) included\n    // in blocked will be ignored by judgeSuspects\n    const blocked = [];\n\n    // Position information for all nodes in the AST,\n    // used for sourcemap generation\n    const nodePositions = [];\n\n    const lut = new Lut(ast, src);\n\n    scopeTools.setupScopeAndReferences(ast);\n\n    const ctx = {\n        mode: mode,\n        quot: quot,\n        src: src,\n        srcForRange: function(range) {\n            return src.slice(range[0], range[1]);\n        },\n        re: re,\n        rename: rename,\n        comments: comments,\n        fragments: fragments,\n        suspects: suspects,\n        blocked: blocked,\n        lut: lut,\n        isFunctionExpressionWithArgs: isFunctionExpressionWithArgs,\n        isFunctionDeclarationWithArgs: isFunctionDeclarationWithArgs,\n        isAnnotatedArray: isAnnotatedArray,\n        addModuleContextDependentSuspect: addModuleContextDependentSuspect,\n        addModuleContextIndependentSuspect: addModuleContextIndependentSuspect,\n        stringify: stringify,\n        nodePositions: nodePositions,\n        matchResolve: matchResolve,\n        matchProp: matchProp,\n        last: last,\n    };\n\n    // setup optionals\n    const optionals = options.enable || [];\n    for (let i = 0; i < optionals.length; i++) {\n        const optional = String(optionals[i]);\n        if (!allOptionals.hasOwnProperty(optional)) {\n            return {\n                errors: [\"error: found no optional named \" + optional],\n            };\n        }\n    }\n    const optionalsPlugins = optionals.map(function(optional) {\n        return allOptionals[optional];\n    });\n\n    const plugins = [].concat(optionalsPlugins, options.plugin || []);\n\n    function matchPlugins(node, isMethodCall) {\n        for (let i = 0; i < plugins.length; i++) {\n            const res = plugins[i].match(node, isMethodCall);\n            if (res) {\n                return res;\n            }\n        }\n        return false;\n    }\n    const matchPluginsOrNull = (plugins.length === 0 ? null : matchPlugins);\n\n    ngInject.inspectComments(ctx);\n    plugins.forEach(function(plugin) {\n        plugin.init(ctx);\n    });\n\n    traverse(ast, {pre: function(node) {\n        ngInject.inspectNode(node, ctx);\n\n    }, post: function(node) {\n        ctx.nodePositions.push(node.loc.start);\n        let targets = match(node, ctx, matchPluginsOrNull);\n        if (!targets) {\n            return;\n        }\n        if (!is.array(targets)) {\n            targets = [targets];\n        }\n\n        for (let i = 0; i < targets.length; i++) {\n            addModuleContextDependentSuspect(targets[i], ctx);\n        }\n    }});\n\n    try {\n        judgeSuspects(ctx);\n    } catch(e) {\n        return {\n            errors: [\"error: \" + e],\n        };\n    }\n\n    uniqifyFragments(ctx.fragments);\n\n    const out = alter(src, fragments);\n    const result = {\n        src: out,\n        _stats: stats,\n    };\n\n    if (options.map) {\n        if (typeof(options.map) !== 'object')\n            options.map = {};\n        stats.sourcemap_t0 = Date.now();\n        generateSourcemap(result, src, nodePositions, fragments, options.map);\n        stats.sourcemap_t1 = Date.now();\n    }\n\n    return result;\n}\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/nginject.js":"// nginject.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\n\nconst is = require(\"simple-is\");\n\nmodule.exports = {\n    inspectComments: inspectComments,\n    inspectNode: inspectNode,\n};\n\nfunction inspectNode(node, ctx) {\n    if (node.type === \"CallExpression\") {\n        inspectCallExpression(node, ctx);\n    } else if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n        inspectFunction(node, ctx);\n    }\n}\n\nfunction inspectCallExpression(node, ctx) {\n    const name = node.callee.name;\n    if (node.callee.type === \"Identifier\" && (name === \"ngInject\" || name === \"ngNoInject\") && node.arguments.length === 1) {\n        const block = (name === \"ngNoInject\");\n        addSuspect(node.arguments[0], ctx, block);\n    }\n}\n\nconst ngAnnotatePrologueDirectives = [\"ngInject\", \"ngNoInject\"];\n\nfunction inspectFunction(node, ctx) {\n    const str = matchPrologueDirectives(ngAnnotatePrologueDirectives, node);\n    if (!str) {\n        return;\n    }\n    const block = (str === \"ngNoInject\");\n\n    // now add the correct suspect\n\n    // for function declarations, it is always the function declaration node itself\n    if (node.type === \"FunctionDeclaration\") {\n        addSuspect(node, ctx, block);\n        return;\n    }\n\n    // node is a function expression below\n\n    // case 1: a function expression which is the rhs of a variable declarator, such as\n    // var f1 = function(a) {\n    //     \"ngInject\"\n    // };\n    // in this case we can mark the declarator, same as saying var /*@ngInject*/ f1 = function(a) ..\n    // or /*@ngInject*/ var f1 = function(a) ..\n    // f1.$inject = [\"a\"]; will be added (or rebuilt/removed)\n    if (node.$parent.type === \"VariableDeclarator\") {\n        addSuspect(node.$parent, ctx, block);\n        return;\n    }\n\n    // case 2: an anonymous function expression, such as\n    // g(function(a) {\n    //     \"ngInject\"\n    // });\n    //\n    // the suspect is now its parent annotated array (if any), otherwise itself\n    // there is a risk of false suspects here, in case the parent annotated array has nothing to do\n    // with annotations. the risk should be very low and hopefully easy to workaround\n    //\n    // added/rebuilt/removed => g([\"a\", function(a) {\n    //     \"ngInject\"\n    // }]);\n    const maybeArrayExpression = node.$parent;\n    if (ctx.isAnnotatedArray(maybeArrayExpression)) {\n        addSuspect(maybeArrayExpression, ctx, block);\n    } else {\n        addSuspect(node, ctx, block);\n    }\n}\n\nfunction matchPrologueDirectives(prologueDirectives, node) {\n    const body = node.body.body;\n\n    let found = null;\n    for (let i = 0; i < body.length; i++) {\n        if (body[i].type !== \"ExpressionStatement\") {\n            break;\n        }\n\n        const expr = body[i].expression;\n        const isStringLiteral = (expr.type === \"Literal\" && typeof expr.value === \"string\");\n        if (!isStringLiteral) {\n            break;\n        }\n\n        if (prologueDirectives.indexOf(expr.value) >= 0) {\n            found = expr.value;\n            break;\n        }\n    }\n\n    return found;\n}\n\nfunction inspectComments(ctx) {\n    const comments = ctx.comments;\n    for (let i = 0; i < comments.length; i++) {\n        const comment = comments[i];\n        const yesPos = comment.value.indexOf(\"@ngInject\");\n        const noPos = (yesPos === -1 ? comment.value.indexOf(\"@ngNoInject\") : -1);\n        if (yesPos === -1 && noPos === -1) {\n            continue;\n        }\n\n        const target = ctx.lut.findNodeFromPos(comment.range[1]);\n        if (!target) {\n            continue;\n        }\n\n        addSuspect(target, ctx, noPos >= 0);\n    }\n}\n\nfunction isStringArray(node) {\n    if (node.type !== \"ArrayExpression\") {\n        return false;\n    }\n    return node.elements.length >= 1 && node.elements.every(function(n) {\n        return n.type === \"Literal\" && is.string(n.value);\n    });\n}\n\nfunction findNextStatement(node) {\n    const body = node.$parent.body;\n    for (let i = 0; i < body.length; i++) {\n        if (body[i] === node) {\n            return body[i + 1] || null;\n        }\n    }\n    return null;\n}\n\nfunction addSuspect(target, ctx, block) {\n    if (target.type === \"ExpressionStatement\" && target.expression.type === \"AssignmentExpression\" && isStringArray(target.expression.right)) {\n        // /*@ngInject*/\n        // FooBar.$inject = [\"$a\", \"$b\"];\n        // function FooBar($a, $b) {}\n        const adjustedTarget = findNextStatement(target);\n        if (adjustedTarget) {\n            return addSuspect(adjustedTarget, ctx, block);\n        }\n    }\n\n    if (target.type === \"ObjectExpression\") {\n        // /*@ngInject*/ {f1: function(a), .., {f2: function(b)}}\n        addObjectExpression(target, ctx);\n    } else if (target.type === \"AssignmentExpression\" && target.right.type === \"ObjectExpression\") {\n        // /*@ngInject*/ f(x.y = {f1: function(a), .., {f2: function(b)}})\n        addObjectExpression(target.right, ctx);\n    } else if (target.type === \"ExpressionStatement\" && target.expression.type === \"AssignmentExpression\" && target.expression.right.type === \"ObjectExpression\") {\n        // /*@ngInject*/ x.y = {f1: function(a), .., {f2: function(b)}}\n        addObjectExpression(target.expression.right, ctx);\n    } else if (target.type === \"VariableDeclaration\" && target.declarations.length === 1 && target.declarations[0].init && target.declarations[0].init.type === \"ObjectExpression\") {\n        // /*@ngInject*/ var x = {f1: function(a), .., {f2: function(b)}}\n        addObjectExpression(target.declarations[0].init, ctx);\n    } else if (target.type === \"Property\") {\n        // {/*@ngInject*/ justthisone: function(a), ..}\n        target.value.$limitToMethodName = \"*never*\";\n        addOrBlock(target.value, ctx);\n    } else {\n        // /*@ngInject*/ function(a) {}\n        target.$limitToMethodName = \"*never*\";\n        addOrBlock(target, ctx);\n    }\n\n\n    function addObjectExpression(node, ctx) {\n        nestedObjectValues(node).forEach(function(n) {\n            n.$limitToMethodName = \"*never*\";\n            addOrBlock(n, ctx);\n        });\n    }\n\n    function addOrBlock(node, ctx) {\n        if (block) {\n            ctx.blocked.push(node);\n        } else {\n            ctx.addModuleContextIndependentSuspect(node, ctx)\n        }\n    }\n}\n\nfunction nestedObjectValues(node, res) {\n    res = res || [];\n\n    node.properties.forEach(function(prop) {\n        const v = prop.value;\n        if (is.someof(v.type, [\"FunctionExpression\", \"ArrayExpression\"])) {\n            res.push(v);\n        } else if (v.type === \"ObjectExpression\") {\n            nestedObjectValues(v, res);\n        }\n    });\n\n    return res;\n}\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/scopetools.js":"// scopetools.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\n\nconst assert = require(\"assert\");\nconst traverse = require(\"ordered-ast-traverse\");\nconst Scope = require(\"./scope\");\nconst is = require(\"simple-is\");\n\nmodule.exports = {\n    setupScopeAndReferences: setupScopeAndReferences,\n    isReference: isReference,\n};\n\nfunction setupScopeAndReferences(root) {\n    traverse(root, {pre: createScopes});\n    createTopScope(root.$scope);\n}\n\nfunction createScopes(node, parent) {\n    node.$parent = parent;\n    node.$scope = parent ? parent.$scope : null; // may be overridden\n\n    if (isNonFunctionBlock(node, parent)) {\n        // A block node is a scope unless parent is a function\n        node.$scope = new Scope({\n            kind: \"block\",\n            node: node,\n            parent: parent.$scope,\n        });\n\n    } else if (node.type === \"VariableDeclaration\") {\n        // Variable declarations names goes in current scope\n        node.declarations.forEach(function(declarator) {\n            const name = declarator.id.name;\n            node.$scope.add(name, node.kind, declarator.id, declarator.range[1]);\n        });\n\n    } else if (isFunction(node)) {\n        // Function is a scope, with params in it\n        // There's no block-scope under it\n\n        node.$scope = new Scope({\n            kind: \"hoist\",\n            node: node,\n            parent: parent.$scope,\n        });\n\n        // function has a name\n        if (node.id) {\n            if (node.type === \"FunctionDeclaration\") {\n                // Function name goes in parent scope for declared functions\n                parent.$scope.add(node.id.name, \"fun\", node.id, null);\n            } else if (node.type === \"FunctionExpression\") {\n                // Function name goes in function's scope for named function expressions\n                node.$scope.add(node.id.name, \"fun\", node.id, null);\n            } else {\n                assert(false);\n            }\n        }\n\n        node.params.forEach(function(param) {\n            node.$scope.add(param.name, \"param\", param, null);\n        });\n\n    } else if (isForWithConstLet(node) || isForInOfWithConstLet(node)) {\n        // For(In/Of) loop with const|let declaration is a scope, with declaration in it\n        // There may be a block-scope under it\n        node.$scope = new Scope({\n            kind: \"block\",\n            node: node,\n            parent: parent.$scope,\n        });\n\n    } else if (node.type === \"CatchClause\") {\n        const identifier = node.param;\n\n        node.$scope = new Scope({\n            kind: \"catch-block\",\n            node: node,\n            parent: parent.$scope,\n        });\n        node.$scope.add(identifier.name, \"caught\", identifier, null);\n\n        // All hoist-scope keeps track of which variables that are propagated through,\n        // i.e. an reference inside the scope points to a declaration outside the scope.\n        // This is used to mark \"taint\" the name since adding a new variable in the scope,\n        // with a propagated name, would change the meaning of the existing references.\n        //\n        // catch(e) is special because even though e is a variable in its own scope,\n        // we want to make sure that catch(e){let e} is never transformed to\n        // catch(e){var e} (but rather var e$0). For that reason we taint the use of e\n        // in the closest hoist-scope, i.e. where var e$0 belongs.\n        node.$scope.closestHoistScope().markPropagates(identifier.name);\n\n    } else if (node.type === \"Program\") {\n        // Top-level program is a scope\n        // There's no block-scope under it\n        node.$scope = new Scope({\n            kind: \"hoist\",\n            node: node,\n            parent: null,\n        });\n    }\n}\n\nfunction createTopScope(programScope) {\n    function inject(obj) {\n        for (let name in obj) {\n            const writeable = obj[name];\n            const kind = (writeable ? \"var\" : \"const\");\n            if (topScope.hasOwn(name)) {\n                topScope.remove(name);\n            }\n            topScope.add(name, kind, {loc: {start: {line: -1}}}, -1);\n        }\n    }\n\n    const topScope = new Scope({\n        kind: \"hoist\",\n        node: {},\n        parent: null,\n    });\n\n    const complementary = {\n        undefined: false,\n        Infinity: false,\n        console: false,\n    };\n\n    inject(complementary);\n//    inject(jshint_vars.reservedVars);\n//    inject(jshint_vars.ecmaIdentifiers);\n\n    // link it in\n    programScope.parent = topScope;\n    topScope.children.push(programScope);\n\n    return topScope;\n}\n\nfunction isConstLet(kind) {\n    return kind === \"const\" || kind === \"let\";\n}\n\nfunction isNonFunctionBlock(node, parent) {\n    return node.type === \"BlockStatement\" && parent.type !== \"FunctionDeclaration\" && parent.type !== \"FunctionExpression\";\n}\n\nfunction isForWithConstLet(node) {\n    return node.type === \"ForStatement\" && node.init && node.init.type === \"VariableDeclaration\" && isConstLet(node.init.kind);\n}\n\nfunction isForInOfWithConstLet(node) {\n    return isForInOf(node) && node.left.type === \"VariableDeclaration\" && isConstLet(node.left.kind);\n}\n\nfunction isForInOf(node) {\n    return node.type === \"ForInStatement\" || node.type === \"ForOfStatement\";\n}\n\nfunction isFunction(node) {\n    return node.type === \"FunctionDeclaration\" || node.type === \"FunctionExpression\";\n}\n\nfunction isReference(node) {\n    const parent = node.$parent;\n    return node.$refToScope ||\n        node.type === \"Identifier\" &&\n            !(parent.type === \"VariableDeclarator\" && parent.id === node) && // var|let|const $\n            !(parent.type === \"MemberExpression\" && parent.computed === false && parent.property === node) && // obj.$\n            !(parent.type === \"Property\" && parent.key === node) && // {$: ...}\n            !(parent.type === \"LabeledStatement\" && parent.label === node) && // $: ...\n            !(parent.type === \"CatchClause\" && parent.param === node) && // catch($)\n            !(isFunction(parent) && parent.id === node) && // function $(..\n            !(isFunction(parent) && is.someof(node, parent.params)) && // function f($)..\n            true;\n}\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/scope.js":"// scope.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\n\nconst assert = require(\"assert\");\nconst stringmap = require(\"stringmap\");\nconst stringset = require(\"stringset\");\nconst is = require(\"simple-is\");\nconst fmt = require(\"simple-fmt\");\n\nfunction Scope(args) {\n    assert(is.someof(args.kind, [\"hoist\", \"block\", \"catch-block\"]));\n    assert(is.object(args.node));\n    assert(args.parent === null || is.object(args.parent));\n\n    // kind === \"hoist\": function scopes, program scope, injected globals\n    // kind === \"block\": ES6 block scopes\n    // kind === \"catch-block\": catch block scopes\n    this.kind = args.kind;\n\n    // the AST node the block corresponds to\n    this.node = args.node;\n\n    // parent scope\n    this.parent = args.parent;\n\n    // children scopes for easier traversal (populated internally)\n    this.children = [];\n\n    // scope declarations. decls[variable_name] = {\n    //     kind: \"fun\" for functions,\n    //           \"param\" for function parameters,\n    //           \"caught\" for catch parameter\n    //           \"var\",\n    //           \"const\",\n    //           \"let\"\n    //     node: the AST node the declaration corresponds to\n    //     from: source code index from which it is visible at earliest\n    //           (only stored for \"const\", \"let\" [and \"var\"] nodes)\n    // }\n    this.decls = stringmap();\n\n    // names of all variables declared outside this hoist scope but\n    // referenced in this scope (immediately or in child).\n    // only stored on hoist scopes for efficiency\n    // (because we currently generate lots of empty block scopes)\n    this.propagates = (this.kind === \"hoist\" ? stringset() : null);\n\n    // scopes register themselves with their parents for easier traversal\n    if (this.parent) {\n        this.parent.children.push(this);\n    }\n}\n\nScope.prototype.print = function(indent) {\n    indent = indent || 0;\n    const scope = this;\n    const names = this.decls.keys().map(function(name) {\n        return fmt(\"{0} [{1}]\", name, scope.decls.get(name).kind);\n    }).join(\", \");\n    const propagates = this.propagates ? this.propagates.items().join(\", \") : \"\";\n    console.log(fmt(\"{0}{1}: {2}. propagates: {3}\", fmt.repeat(\" \", indent), this.node.type, names, propagates));\n    this.children.forEach(function(c) {\n        c.print(indent + 2);\n    });\n};\n\nScope.prototype.add = function(name, kind, node, referableFromPos) {\n    assert(is.someof(kind, [\"fun\", \"param\", \"var\", \"caught\", \"const\", \"let\"]));\n\n    function isConstLet(kind) {\n        return is.someof(kind, [\"const\", \"let\"]);\n    }\n\n    let scope = this;\n\n    // search nearest hoist-scope for fun, param and var's\n    // const, let and caught variables go directly in the scope (which may be hoist, block or catch-block)\n    if (is.someof(kind, [\"fun\", \"param\", \"var\"])) {\n        while (scope.kind !== \"hoist\") {\n//            if (scope.decls.has(name) && isConstLet(scope.decls.get(name).kind)) { // could be caught\n//                return error(getline(node), \"{0} is already declared\", name);\n//            }\n            scope = scope.parent;\n        }\n    }\n    // name exists in scope and either new or existing kind is const|let => error\n//    if (scope.decls.has(name) && (isConstLet(scope.decls.get(name).kind) || isConstLet(kind))) {\n//        return error(getline(node), \"{0} is already declared\", name);\n//    }\n\n    const declaration = {\n        kind: kind,\n        node: node,\n    };\n    if (referableFromPos) {\n        assert(is.someof(kind, [\"var\", \"const\", \"let\"]));\n        declaration.from = referableFromPos;\n    }\n    scope.decls.set(name, declaration);\n};\n\nScope.prototype.getKind = function(name) {\n    assert(is.string(name));\n    const decl = this.decls.get(name);\n    return decl ? decl.kind : null;\n};\n\nScope.prototype.getNode = function(name) {\n    assert(is.string(name));\n    const decl = this.decls.get(name);\n    return decl ? decl.node : null;\n};\n\nScope.prototype.getFromPos = function(name) {\n    assert(is.string(name));\n    const decl = this.decls.get(name);\n    return decl ? decl.from : null;\n};\n\nScope.prototype.hasOwn = function(name) {\n    return this.decls.has(name);\n};\n\nScope.prototype.remove = function(name) {\n    return this.decls.remove(name);\n};\n\nScope.prototype.doesPropagate = function(name) {\n    return this.propagates.has(name);\n};\n\nScope.prototype.markPropagates = function(name) {\n    this.propagates.add(name);\n};\n\nScope.prototype.closestHoistScope = function() {\n    let scope = this;\n    while (scope.kind !== \"hoist\") {\n        scope = scope.parent;\n    }\n    return scope;\n};\n\nScope.prototype.lookup = function(name) {\n    for (let scope = this; scope; scope = scope.parent) {\n        if (scope.decls.has(name)) {\n            return scope;\n        } else if (scope.kind === \"hoist\") {\n            scope.propagates.add(name);\n        }\n    }\n    return null;\n};\n\nmodule.exports = Scope;\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/optionals/angular-dashboard-framework.js":"\"use strict\";\n\nlet ctx = null;\nmodule.exports = {\n    init: function(_ctx) {\n        ctx = _ctx;\n    },\n\n    match: function(node) {\n        // dashboardProvider.widget(\"name\", {\n        //   ...\n        //   controller: function($scope) {},\n        //   resolve: {f: function($scope) {}, ..}\n        // })\n\n        const callee = node.callee;\n        if (!callee) {\n            return false;\n        }\n\n        const obj = callee.object;\n        if (!obj) {\n            return false;\n        }\n\n        // identifier or expression\n        if (!(obj.$chained === 1 || (obj.type === \"Identifier\" && obj.name === \"dashboardProvider\"))) {\n            return false;\n        }\n\n        node.$chained = 1;\n\n        const method = callee.property; // identifier\n        if (method.name !== \"widget\") {\n            return false;\n        }\n\n        const args = node.arguments;\n        if (args.length !== 2) {\n            return false;\n        }\n\n        const configArg = ctx.last(args);\n        if (configArg.type !== \"ObjectExpression\") {\n            return false;\n        }\n\n        const props = configArg.properties;\n        const res = [\n            ctx.matchProp(\"controller\", props)\n        ];\n        // {resolve: ..}\n        res.push.apply(res, ctx.matchResolve(props));\n\n        // edit: {controller: function(), resolve: {}, apply: function()}\n        const edit = ctx.matchProp('edit', props);\n        if (edit && edit.type === \"ObjectExpression\") {\n            const editProps = edit.properties;\n            res.push(ctx.matchProp('controller', editProps));\n            res.push(ctx.matchProp('apply', editProps));\n            res.push.apply(res, ctx.matchResolve(editProps));\n        }\n\n        const filteredRes = res.filter(Boolean);\n        return (filteredRes.length === 0 ? false : filteredRes);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-ng-annotate/node_modules/ng-annotate/pos-to-linecolumn.js":"// pos-to-linecolumn.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2014-2016 Olov Lassus <olov.lassus@gmail.com>\n\n\"use strict\";\n\nconst assert = require(\"assert\");\n\nmodule.exports = PosToLineColumn;\n\nfunction PosToLineColumn(str) {\n    if (!(this instanceof PosToLineColumn)) {\n        throw new Error(\"PosToLineColumn requires new\");\n    }\n    str = String(str);\n\n    const newlines = [];\n    let pos = -1;\n    while ((pos = str.indexOf(\"\\n\", pos + 1)) >= 0) {\n        newlines.push(pos);\n    }\n\n    let line = 1;\n    let column = 0;\n    const columns = [];\n    const lines = [];\n    let i;\n    let j = 0;\n    for (i = 0; i < str.length; i++) {\n        columns[i] = column;\n        lines[i] = line;\n\n        if (i === newlines[j]) {\n            ++j;\n            ++line;\n            column = 0;\n        } else {\n            ++column;\n        }\n    }\n\n    // add extra entry to support pos === str.length\n    columns[i] = column;\n    lines[i] = line;\n\n    this.len = str.length;\n    this.columns = columns;\n    this.lines = lines;\n}\n\nPosToLineColumn.prototype.toLine = function(pos) {\n    assert(pos >= 0 && pos <= this.len);\n    return this.lines[pos];\n};\n\nPosToLineColumn.prototype.toColumn = function(pos) {\n    assert(pos >= 0 && pos <= this.len);\n    return this.columns[pos];\n};\n\nPosToLineColumn.prototype.toLineColumn = function(pos) {\n    return {\n        line: this.toLine(pos),\n        column: this.toColumn(pos),\n    };\n};\n\n\n/*\nconst tst = \"asdf\\n\" +\n    \"abc\\n\" +\n    \"d\\n\" +\n    \"\\n\\n\" +\n    \"efghi a\\r\\n\" +\n    \"x\";\nconst instance = new PosToLineColumn(tst);\nconsole.dir(instance.toLineColumn(0));\nconsole.dir(instance.toLineColumn(tst.length));\n*/\n"}